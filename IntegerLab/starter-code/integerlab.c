/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file integerlab.c
 *
 * @author Christopher A. Bohn
 *
 * @brief Driver code for IntegerLab.
 *
 ******************************************************************************/

/*
 * IntegerLab (c) 2018-22 Christopher A. Bohn
 *
 * Assignment and starter code licensed under the Apache License,
 * Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include "alu.h"

struct authoritative_result {
    uint16_t result;
    uint16_t supplemental_result;
    uint8_t z_flag;
    uint8_t s_flag;
    uint8_t o_flag;
    uint8_t c_flag;
};

bool read_evaluate_print();
char *parse_operand(const char *buffer, uint32_t *operand);
char *parse_operator(const char *buffer, char *operator);
void evaluate_print_one_bit_adder(const char *input_buffer);
void evaluate_print_thirty_two_bit_adder(const char *input_buffer);
void evaluate_print_arithmetic(uint16_t operand1, char operator, uint16_t operand2);
void evaluate_addition(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);
void evaluate_subtraction(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);
void evaluate_unsigned_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);
void evaluate_unsigned_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);
void evaluate_signed_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);
void evaluate_signed_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result);

int main() {
    bool running = true;
    while (running) {
        running = read_evaluate_print();
        printf("\n");
    }
    printf("Goodbye\n");
    return 0;
}

char *parse_operand(const char *buffer, uint32_t *operand) {
    char *end_pointer[1];
    while (*buffer == ' ' || *buffer == '\t') {
        buffer++;
    }
    *operand = strtol(buffer, end_pointer, (strncmp(buffer, "0x", 2) ? 10 : 16));
    return end_pointer[0];
}

char *parse_operator(const char *buffer, char operator[3]) {
    const char *end_pointer = buffer;
    while (*end_pointer == ' ' || *end_pointer == '\t') {
        end_pointer++;
    }
    operator[0] = *end_pointer++;
    if (*end_pointer == ' ' || *end_pointer == '\t' || isdigit(*end_pointer)) {
        operator[1] = '\0';
    } else {
        operator[1] = *end_pointer++;
        operator[2] = '\0';
    }
    return (char *) end_pointer;
}

void evaluate_print_one_bit_adder(const char *input_buffer) {
    /* !!! STUDENTS ARE NOT ALLOWED TO USE A LOOKUP TABLE FOR THEIR ONE-BIT ADDER !!! */
    bool sums[2][2][2] = {{{false, true},  {true,  false}},
                          {{true,  false}, {false, true}}};
    bool carries[2][2][2] = {{{false, false}, {false, true}},
                             {{false, true},  {true,  true}}};
    /* !!! STUDENTS ARE NOT ALLOWED TO USE A LOOKUP TABLE FOR THEIR ONE-BIT ADDER !!! */
    one_bit_adder_t input;
    uint32_t operand;
    char *next = parse_operand(input_buffer + 5, &operand);
    input.a = operand & 0x1;
    next = parse_operand(next, &operand);
    input.b = operand & 0x1;
    parse_operand(next, &operand);
    input.c_in = operand & 0x1;
    one_bit_adder_t result = one_bit_full_addition(input);
    printf("expected: %d + %d + %d = %d carry %d\n", input.a, input.b, input.c_in,
           sums[input.a][input.b][input.c_in], carries[input.a][input.b][input.c_in]);
    printf("actual:   %d + %d + %d = %d carry %d\n", result.a, result.b, result.c_in, result.sum, result.c_out);
}

void evaluate_print_thirty_two_bit_adder(const char *input_buffer) {
    uint32_t operand1, operand2;
    int carry_in;
    sscanf(input_buffer + 6, "%x %x %d", &operand1, &operand2, &carry_in); // NOLINT(cert-err34-c)
    uint32_t expected_result = operand1 + operand2 + (carry_in & 0x1);
    uint32_t actual_result = ripple_carry_addition(operand1, operand2, (uint8_t) carry_in);
    printf("expected: 0x%08X + 0x%08X + %d = 0x%08X\n", operand1, operand2, (carry_in & 0x1), expected_result);
    printf("actual:   0x%08X + 0x%08X + %d = 0x%08X\n", operand1, operand2, (carry_in & 0x1), actual_result);
}

void evaluate_print_arithmetic(uint16_t operand1, char operator, uint16_t operand2) {
    alu_result_t actual_result;
    struct authoritative_result *expected_result = malloc(sizeof(struct authoritative_result));
    switch (operator) {
        case '+':
        case '-':
            if (operator == '+') {
                evaluate_addition(operand1, operand2, expected_result);
                actual_result = add(operand1, operand2);
            } else {
                evaluate_subtraction(operand1, operand2, expected_result);
                actual_result = subtract(operand1, operand2);
            }
            printf("UNSIGNED %s\n", operator == '+' ? "ADDITION" : "SUBTRACTION");
            printf("\texpected result (hexadecimal): 0x%04X %c 0x%04X = 0x%04X\n",
                   operand1, operator, operand2, expected_result->result);
            printf("\texpected result (unsigned):    %u %c %u = %u\toverflow: %s\n",
                   operand1, operator, operand2, expected_result->result,
                   expected_result->c_flag ? "true" : "false");
            printf("\tactual result (hexadecimal):   0x%04X %c 0x%04X = 0x%04X\n",
                   operand1, operator, operand2, actual_result.result);
            printf("\tactual result (unsigned):      %u %c %u = %u\toverflow: %s\n",
                   operand1, operator, operand2, actual_result.result,
                   actual_result.unsigned_overflow ? "true" : "false");
            printf("SIGNED %s\n", operator == '+' ? "ADDITION" : "SUBTRACTION");
            printf("\texpected result (hexadecimal): 0x%04X %c 0x%04X = 0x%04X\n",
                   operand1, operator, operand2, expected_result->result);
            printf("\texpected result (signed):      %d %c %d = %d\toverflow: %s\n",
                   (int16_t) operand1, operator, (int16_t) operand2, (int16_t) expected_result->result,
                   expected_result->o_flag ? "true" : "false");
            printf("\tactual result (hexadecimal):   0x%04X %c 0x%04X = 0x%04X\n",
                   operand1, operator, operand2, actual_result.result);
            printf("\tactual result (signed):        %d %c %d = %d\toverflow: %s\n",
                   (int16_t) operand1, operator, (int16_t) operand2, (int16_t) actual_result.result,
                   actual_result.signed_overflow ? "true" : "false");
            break;
        case '*':
            printf("UNSIGNED MULTIPLICATION\n");
            evaluate_unsigned_multiplication(operand1, operand2, expected_result);
            actual_result = unsigned_multiply(operand1, operand2);
            printf("\texpected result (hexadecimal): 0x%04X * 0x%04X = 0x%04X'%04X\n",
                   operand1, operand2, expected_result->supplemental_result, expected_result->result);
            printf("\texpected result (unsigned):    %u * %u = %u (%u)\n", operand1, operand2, expected_result->result,
                   ((uint32_t) expected_result->supplemental_result << 16) | expected_result->result);
            printf("\tactual result (hexadecimal):   0x%04X * 0x%04X = 0x%04X'%04X\n",
                   operand1, operand2, actual_result.supplemental_result, actual_result.result);
            printf("\tactual result (unsigned):      %u * %u = %u (%u)\n", operand1, operand2, actual_result.result,
                   ((uint32_t) actual_result.supplemental_result << 16) | actual_result.result);
            printf("SIGNED MULTIPLICATION\n");
            evaluate_signed_multiplication(operand1, operand2, expected_result);
            actual_result = signed_multiply(operand1, operand2);
            printf("\texpected result (hexadecimal): 0x%04X * 0x%04X = 0x%04X'%04X\n",
                   operand1, operand2, expected_result->supplemental_result, expected_result->result);
            printf("\texpected result (signed):      %d * %d = %d (%d)\n",
                   (int16_t) operand1, (int16_t) operand2, (int16_t) expected_result->result,
                   (int32_t) (((uint32_t) expected_result->supplemental_result << 16) | expected_result->result));
            printf("\tactual result (hexadecimal):   0x%04X * 0x%04X = 0x%04X'%04X\n",
                   operand1, operand2, actual_result.supplemental_result, actual_result.result);
            printf("\tactual result (signed):        %d * %d = %d (%d)\n",
                   (int16_t) operand1, (int16_t) operand2, (int16_t) actual_result.result,
                   (int32_t) (((uint32_t) actual_result.supplemental_result << 16) | actual_result.result));
            break;
        case '/':
        case '%':
            if (operand2 > 0 && operand2 != 1 << lg(operand2)) {
                printf("[NOTE] 0x%04X is not a power-of-two; the assignment only requires division by powers-of-two.\n",
                       operand2);
            }
            printf("UNSIGNED DIVISION\n");
            if (operand2 == 0) {
                printf("expected result: divide-by-zero\n");
            } else {
                evaluate_unsigned_division(operand1, operand2, expected_result);
                printf("\texpected result (hexadecimal): 0x%04X / 0x%04X = 0x%04X    0x%04X %% 0x%04X = 0x%04X\n",
                       operand1, operand2, expected_result->result,
                       operand1, operand2, expected_result->supplemental_result);
                printf("\texpected result (unsigned):    %u / %u = %u    %u %% %u = %u\n",
                       operand1, operand2, expected_result->result,
                       operand1, operand2, expected_result->supplemental_result);
            }
            actual_result = unsigned_divide(operand1, operand2);
            if (actual_result.divide_by_zero) {
                printf("actual result:   divide-by-zero\n");
            } else {
                printf("\tactual result (hexadecimal):   0x%04X / 0x%04X = 0x%04X    0x%04X %% 0x%04X = 0x%04X\n",
                       operand1, operand2, actual_result.result,
                       operand1, operand2, actual_result.supplemental_result);
                printf("\tactual result (unsigned):      %u / %u = %u    %u %% %u = %u\n",
                       operand1, operand2, actual_result.result,
                       operand1, operand2, actual_result.supplemental_result);
            }
            printf("SIGNED DIVISION\n");
            if (operand2 == 0) {
                printf("expected result: divide-by-zero\n");
            } else {
                evaluate_signed_division(operand1, operand2, expected_result);
                printf("\texpected result (hexadecimal): 0x%04X / 0x%04X = 0x%04X    0x%04X %% 0x%04X = 0x%04X\n",
                       operand1, operand2, expected_result->result,
                       operand1, operand2, expected_result->supplemental_result);
                printf("\texpected result (signed):      %d / %d = %d    %d %% %d = %d\n",
                       (int16_t) operand1, (int16_t) operand2, (int16_t) expected_result->result,
                       (int16_t) operand1, (int16_t) operand2, (int16_t) expected_result->supplemental_result);
            }
            actual_result = signed_divide(operand1, operand2);
            if (actual_result.divide_by_zero) {
                printf("actual result:   divide-by-zero\n");
            } else {
                printf("\tactual result (hexadecimal):   0x%04X / 0x%04X = 0x%04X    0x%04X %% 0x%04X = 0x%04X\n",
                       operand1, operand2, actual_result.result,
                       operand1, operand2, actual_result.supplemental_result);
                printf("\tactual result (signed):        %d / %d = %d    %d %% %d = %d\n",
                       (int16_t) operand1, (int16_t) operand2, (int16_t) actual_result.result,
                       (int16_t) operand1, (int16_t) operand2, (int16_t) actual_result.supplemental_result);
            }
            break;
        default:
            printf("Unknown operator: %c\n", operator);
    }
}

bool read_evaluate_print() {
    char input_buffer[72];
    uint32_t operand1, operand2;
    char operator[3];
    bool keep_going = true;
    printf("Enter a one- or two-operand logical expression, \n"
           "    a two-operand comparison expression, a two-operand arithmetic expression,\n"
           "    \"lg <value>\" or \"exponentiate <value>\" to test your powers-of-two code,\n"
           "    \"is_negative <value>\" to determine if 2's complement value is negative,\n"
           "    \"add1 <binary_value1> <binary_value2> <carry_in>\" for 1-bit full adder,\n"
           "    \"add32 <hex_value1> <hex_value2> <carry_in>\" for 32-bit ripple-carry adder,\n"
           "    or \"quit\": ");
    fgets(input_buffer, 72, stdin);
    // string to lowercase, to simplify a couple of the comparisons
    for (char *s = input_buffer; (*s = (char) tolower(*s)); s++) {}
    if (!strncmp(input_buffer, "quit", 4)) {
        keep_going = false;
    } else if (!strncmp(input_buffer, "lg", 2)) {
        parse_operand(input_buffer + 2, &operand1);
        printf("expected: log2 %u == log2 0x%08X == %d\n", operand1, operand1, (int) log2(operand1));
        printf("actual:   log2 %u == log2 0x%08X == %d\n", operand1, operand1, lg(operand1));
    } else if (!strncmp(input_buffer, "exponentiate", 12)) {
        parse_operand(input_buffer + 12, &operand1);
        printf("expected: 2**%d == 0x%08X == %u\n",
               operand1, (unsigned int) pow(2, operand1), (unsigned int) pow(2, operand1));
        printf("actual:   2**%d == 0x%08X == %u\n",
               operand1, exponentiate((int) operand1), exponentiate((int) operand1));
    } else if (!strncmp(input_buffer, "is_negative", 11)
               || !strncmp(input_buffer, "is-negative", 11)
               || !strncmp(input_buffer, "is negative", 11)
               || !strncmp(input_buffer, "isnegative", 10)) {
        parse_operand(input_buffer + 11, &operand1);
        printf("expected: %d (0x%04X) %s negative\n",
               (int16_t) operand1, (uint16_t) operand1, ((int16_t) operand1 < 0 ? "is" : "is not"));
        printf("actual:   %d (0x%04X) %s negative\n",
               (int16_t) operand1, (uint16_t)operand1, (is_negative(operand1) ? "is" : "is not"));
    } else if (!strncmp(input_buffer, "add1", 4)) {
        evaluate_print_one_bit_adder(input_buffer);
    } else if (!strncmp(input_buffer, "add32", 5)) {
        evaluate_print_thirty_two_bit_adder(input_buffer);
    } else {
        char *next;
        if (isdigit(input_buffer[0]) || input_buffer[0] == '-') {
            next = parse_operand(input_buffer, &operand1);
        } else {
            next = input_buffer;
            operand1 = 0;
        }
        next = parse_operator(next, operator);
        parse_operand(next, &operand2);
        switch (operator[0]) {
            case '+':
            case '-':
            case '*':
            case '/':
            case '%':
                evaluate_print_arithmetic(operand1, operator[0], operand2);
                break;
            case '!':
                if (operator[1] == '\0') {
                    printf("expected: !%d = %d\n", operand2, !operand2);
                    printf("actual:   !%d = %d\n", operand2, logical_not(operand2));
                } else if (operator[1] == '=') {
                    printf("expected: (%d != %d) = %d\n", operand1, operand2, operand1 != operand2);
                    printf("actual:   (%d != %d) = %d\n", operand1, operand2, not_equal(operand1, operand2));
                } else {
                    printf("Unknown operator: %s\n", operator);
                }
                break;
            case '&':
                printf("expected: %d && %d = %d\n", operand1, operand2, operand1 && operand2);
                printf("actual:   %d && %d = %d\n", operand1, operand2, logical_and(operand1, operand2));
                break;
            case '|':
                printf("expected: %d || %d = %d\n", operand1, operand2, operand1 || operand2);
                printf("actual:   %d || %d = %d\n", operand1, operand2, logical_or(operand1, operand2));
                break;
            case '=':
                printf("expected: (%d == %d) = %d\n", operand1, operand2, operand1 == operand2);
                printf("actual:   (%d == %d) = %d\n", operand1, operand2, equal(operand1, operand2));
                break;
            case '<':
                if (operator[1] == '\0') {
                    printf("expected: (%d < %d) = %d\n", operand1, operand2, operand1 < operand2);
                    printf("actual:   (%d < %d) = %d\n", operand1, operand2, less_than(operand1, operand2));
                } else if (operator[1] == '=') {
                    printf("expected: (%d <= %d) = %d\n", operand1, operand2, operand1 <= operand2);
                    printf("actual:   (%d <= %d) = %d\n", operand1, operand2, at_most(operand1, operand2));
                } else {
                    printf("Unknown operator: %s\n", operator);
                }
                break;
            case '>':
                if (operator[1] == '\0') {
                    printf("expected: (%d > %d) = %d\n", operand1, operand2, operand1 > operand2);
                    printf("actual:   (%d > %d) = %d\n", operand1, operand2, greater_than(operand1, operand2));
                } else if (operator[1] == '=') {
                    printf("expected: (%d >= %d) = %d\n", operand1, operand2, operand1 >= operand2);
                    printf("actual:   (%d >= %d) = %d\n", operand1, operand2, at_least(operand1, operand2));
                } else {
                    printf("Unknown operator: %s\n", operator);
                }
                break;
            default:
                printf("Unknown operator: %s\n", operator);
        }
    }
    return keep_going;
}

/*
 * ISA-SPECIFIC CODE FOLLOWS
 */

#if defined __linux__ || defined __APPLE__ || defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__ || defined __unix__
//#if defined _POSIX_VERSION || defined _XOPEN_VERSION  // this didn't work on my Mac

// for now, assume a 64-bit machine;
// see https://github.com/cpredef/predef/blob/master/Architectures.md for IA32 macros if we change that assumption
// (see that link also for ARM macros when we get to that)

#if defined __x86_64__ || defined _M_X64

/* !!! STUDENTS ARE NOT ALLOWED TO USE INLINE ASSEMBLY TO IMPLEMENT ARITHMETIC !!! */

void evaluate_addition(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "addw %si, %di\n"
            "setz 4(%rdx)\n"
            "sets 5(%rdx)\n"
            "seto 6(%rdx)\n"
            "setc 7(%rdx)\n"
            "movw %di, (%rdx)\n"
            );
}

void evaluate_subtraction(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "subw %si, %di\n"
            "sete 4(%rdx)        # z_flag = ZF\n"
            "sets 5(%rdx)        # s_flag = SF\n"
            "setl 6(%rdx)        # o_flag = SF ^ OF\n"
            "setb 7(%rdx)        # c_flag = CF\n"
            "movw %di, (%rdx)\n"
            );
    // right now, result->o_flag has SF^OF, and result->s_flag has SF
    // we can make result->o_flag have OF by noting that (SF^OF)^SF == OF
    result->o_flag ^= result->s_flag;
}

void evaluate_unsigned_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "pushq %rax\n"
            "pushq %rdx\n"
            "movw %di, %ax\n"
            "mulw %si\n"
            "movw %dx, %di\n"
            "popq %rdx\n"
            "setz 4(%rdx)\n"
            "sets 5(%rdx)\n"
            "seto 6(%rdx)\n"
            "setc 7(%rdx)\n"
            "movw %ax, (%rdx)\n"
            "movw %di, 2(%rdx)\n"
            "popq %rax\n"
            );
}

void evaluate_unsigned_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "pushq %rax\n"
            "pushq %rdx\n"
            "movw %di, %ax\n"
            "movw $0, %dx\n"
            "divw %si\n"
            "movw %dx, %di\n"
            "popq %rdx\n"
            "setz 4(%rdx)\n"
            "sets 5(%rdx)\n"
            "seto 6(%rdx)\n"
            "setc 7(%rdx)\n"
            "movw %ax, (%rdx)\n"
            "movw %di, 2(%rdx)\n"
            "popq %rax\n"
            );
}

void evaluate_signed_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "pushq %rax\n"
            "pushq %rdx\n"
            "movw %di, %ax\n"
            "imulw %si\n"
            "movw %dx, %di\n"
            "popq %rdx\n"
            "setz 4(%rdx)\n"
            "sets 5(%rdx)\n"
            "seto 6(%rdx)\n"
            "setc 7(%rdx)\n"
            "movw %ax, (%rdx)\n"
            "movw %di, 2(%rdx)\n"
            "popq %rax\n"
            );
}

void evaluate_signed_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    __asm__(
            "pushq %rax\n"
            "pushq %rdx\n"
            "movw %di, %ax\n"
            "movw $0, %dx\n"
            "testw %ax, %ax\n"
            //            "cmovs $-1, %rdx\n"
            "jns .Linline\n"
            "movw $-1, %dx\n"
            ".Linline:\n"
            // the previous three instructions substitute for the cmov instruction
            "idivw %si\n"
            "movw %dx, %di\n"
            "popq %rdx\n"
            "setz 4(%rdx)\n"
            "sets 5(%rdx)\n"
            "seto 6(%rdx)\n"
            "setc 7(%rdx)\n"
            "movw %ax, (%rdx)\n"
            "movw %di, 2(%rdx)\n"
            "popq %rax\n"
            );
}

/* !!! STUDENTS ARE NOT ALLOWED TO USE INLINE ASSEMBLY TO IMPLEMENT ARITHMETIC !!! */

#else
#warning Some of the code to determine the *expected* supplemental_result and *expected* flags is not yet defined for your processor.
#define INTEGERLAB_MINIMAL_EXPECTED_ARITHMETIC
#endif //processor
#else
#warning Some of the code to determine the *expected* supplemental_result and *expected* flags is not yet defined for your operating system.
#define INTEGERLAB_MINIMAL_EXPECTED_ARITHMETIC
#endif //operating system


#if defined INTEGERLAB_MINIMAL_EXPECTED_ARITHMETIC

void evaluate_addition(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = operand1 + operand2;
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

void evaluate_subtraction(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = operand1 - operand2;
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

void evaluate_unsigned_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = operand1 * operand2;
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

void evaluate_unsigned_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = operand1 / operand2;
    result->supplemental_result = operand1 % operand2;
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

void evaluate_signed_multiplication(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = (uint16_t)((int16_t)operand1 * (int16_t)operand2);
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

void evaluate_signed_division(uint16_t operand1, uint16_t operand2, struct authoritative_result *result) {
    result->result = (uint16_t)((int16_t)operand1 / (int16_t)operand2);
    result->supplemental_result = (uint16_t)((int16_t)operand1 % (int16_t)operand2);
    result->z_flag = !result->result;
    result->s_flag = ((int16_t)(result->result) < 0);
}

#endif //INTEGERLAB_MINIMAL_EXPECTED_ARITHMETIC
