%%
%% FloatLab (c) 2019-22 Christopher A. Bohn
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%     http://www.apache.org/licenses/LICENSE-2.0
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%

\input{../../common/assignment.tex}
\input{../../common/semester.tex}

\renewcommand{\labnumber}{\floatlabnumber}
\renewcommand{\labname}{Floating Point Representation and Arithmetic Lab}
\renewcommand{\shortlabname}{floatlab}
\renewcommand{\collaborationrules}{\floatlabcollaboration}
\renewcommand{\duedate}{\floatlabdue}

\pagelayout
\begin{document}
    \labidentifier

    In this assignment, you will become more familiar with bit-level representations of floating point numbers.
    You'll do this by implementing floating point arithmetic for 32-bit floating point numbers using only bitwise operators and integer arithmetic.

    The instructions are written assuming you will edit and run the code on \runtimeenvironment.
    If you wish, you may edit and run the code in a different environment;
    be sure that your compiler suppresses no warnings, and that if you are using an IDE that it is configured for C and not C++.

    \section*{Learning Objectives}

    After successful completion of this assignment, students will be able to:
    \begin{itemize}
        \item Identify the bit fields of an IEEE~754-compliant floating point number
        \item Obtain the value of an IEEE~754-compliant floating point number
        \item Manipulate IEEE~754-compliant floating point numbers in a meaningful way
        \item Apply IEEE~754 ``round-to-nearest-even'' rounding
    \end{itemize}

    \subsection*{Continuing Forward}

    The familiarity you gain with the IEEE~754 format will pay off handsomely on the first exam.

    \section*{During Lab Time}

    During your lab period, the TAs will provide a refresher of the IEEE~754 format, with a particular emphasis on single-precision floating point numbers, and they will guide students through a discussion and discovery of useful bitmasks for this lab.
    During the remaining time, the TAs will be available to answer questions.

    \softwareengineeringfrontmatter


    \section{Scenario}

    Herb tells you that, Eclectic Electronics tested the integrated circuit that the C-licon tool created from your ALU code, and they've concluded that C-licon is ready to use for their new experimental microprocessor.
    He tasks you with writing C code (that will be used by the C-licon tool) to implement a Floating Point Unit (FPU).
    Your task will be to implement floating point addition, subtraction, multiplication, and division.
    You can use any bit operations and, thanks to the ALU you wrote, you can use any arithmetic operations (use the conventional + - * / operators).
    Because the FPU has not yet been implemented, you cannot use C's floating point operations, you cannot use \lstinline{float}s nor \lstinline{double}s, and you cannot use library functions.


    \section{Getting Started}

    Download \textit{\shortlabname.zip} or \textit{\shortlabname.tar} from \filesource\ and copy it to \runtimeenvironment.
    Once copied, unpackage the file.
    Three of the four files (\textit{fpu.h}, \textit{fpu.c}, and \textit{floatlab.c}) contain the starter code for this assignment.
    The last file (\textit{Makefile}) tells the \texttt{make} utility how to compile the code.
    To compile the program, type:

    \texttt{make}

    This will produce an executable file called \textit{floatlab}.

    When you run the program with the command \texttt{\textbf{\textit{./floatlab}}}, you will be prompted:

    \begin{verbatim}
    Enter a value, a two-operand arithmetic expression,
        "denormalize <value> <change exponent amount>",
        "renormalize <value> <change exponent amount>",
        or "quit":
    \end{verbatim}

    When you enter a value, if it is prepended with \texttt{\textbf{\textit{0x}}} then the parser will treat it as a bit vector;
    otherwise, the parser will treat it as a floating point value.

    For now, type \texttt{\textbf{\textit{quit}}} to exit the program.


    \section{Description of FloatLab Files}

    \subsection{floatlab.c}

    Do not edit \textit{floatlab.c}.

    This file contains the driver code for the lab, as well as a couple of helper functions.
    It parses your input, calls the appropriate arithmetic function, and displays the output.

    \subsection{fpu.h}\label{subsec:fpu.h}

    Do not edit \textit{fpu.h}.

    This header file contains two type definitions:
    \begin{description}
        \item[ieee754\_t] is a 32-bit bit vector that represents a floating point number.
            The bit vector is to be interpreted as though it were a single-precision floating point value in the IEEE~754 format.
            The value may be in the normal form, in the subnormal form, or one of the special cases (NaN, infinity, or zero).
        \item[unnormal\_t] is a structure to hold the components of a floating point number that does not have to be in the IEEE~754 format.
            We expect that you will find the structure useful when performing arithmetic.
            The fields contain enough bits for you to produce exact results that can later be rounded to fit into the normal form.
            While you are not required to do so, we recommend that you place the ``ones'' bit ($2^0$) of the integer portion in the least significant bit of the \lstinline{integer_portion} field, the ``halves'' bit ($2^{-1}$) of the fractional portion in the most significant bit of the \lstinline{fractional_portion} field, and the remaining fractional bits in their appropriate locations relative to the ``halves'' bit.
            We recommend that you store absolute values of the integer and fractional portions, using the 1-bit \lstinline{sign} field to indicate whether the value is positive or negative.
            We further recommend that you use the \lstinline{exponent} field to store the exponent as a two's complement integer and not as a biased integer.
            There are \lstinline{is_infinite} and \lstinline{is_nan} 1-bit fields available to indicate special values.
    \end{description}
    The header file also contains several function declarations.
    The requirements for these functions will be discussed later in this assignment.

    \subsection{fpu.c}

    This file contains stubs for constants and functions you need to create.


    \section{FloatLab Tasks}

    The \textit{only} file you should edit is \textit{fpu.c}.
    You may, of course, view the other files.

    \subsection{Constants}

    There are seven named constants in \textit{fpu.c}.

    Assign the appropriate bit vectors to \lstinline{SIGN_BIT_MASK}, \lstinline{EXPONENT_BITS_MASK}, and \lstinline{FRACTION_BITS_MASK} so that you can use them to mask-off the sign bit, the exponent bits, and the fraction bits, respectively, in a \lstinline{ieee754_t} floating point value.
    Next, assign the single-precision exponent bias to \lstinline{EXPONENT_BIAS} and assign to \lstinline{NUMBER_OF_FRACTION_BITS} the number of bits used for the fraction bit field in a single-precision floating point number.
    Finally, assign to \lstinline{NAN} and \lstinline{INFINITY} the appropriate bit vectors for single-precision Infinity and Not-a-Number.

    These constants will not be graded directly;
    they exist solely to make your code more readable.
    You may define additional named constants as needed.

    \subsection{Query Functions}

    There are three functions to identify whether an \lstinline{ieee754_t} floating point value is Not-a-Number (\function{is_nan()}), is infinity (\function{is_infinity()}), or is zero (\function{is_zero()}).
    Implement these functions to correctly detect their special cases without regard to the value's sign.

    The remaining query function (\function{is_negative()}) determines whether an \lstinline{ieee754_t} floating point value is negative.
    Implement this function.

    \subsection{Printing a IEEE~754-Compliant Value}

    Examine the stub for \function{ieee754_to_string()}.
    This function prints its \lstinline{ieee754_t} argument bit vector in hexadecimal, and then it is supposed to print the bit vector as a binary floating point value.
    Making use of the query functions that you wrote, the stub prints the sign and handles the special cases.

    Find this code:

    \begin{lstlisting}
// The number is either Normal or Subnormal
int integer_portion = 0;
uint32_t fraction = 0;
int exponent = 0;
char fraction_string[40];
/* DETERMINE THE INTEGER PORTION, THE FRACTION, AND THE EXPONENT */
    \end{lstlisting}

    Assign the appropriate values to \lstinline{integer_portion}, \lstinline{fraction}, and \lstinline{exponent}.
    The floating point value's sign is also the \lstinline{integer_portion}'s sign.
    The \lstinline{fraction} is simply the fraction bits as they appear in the lstinline{number}.
    The \lstinline{exponent} is the two's complement representation of the exponent that you get after removing the bias from the \lstinline{number}'s \texttt{E} field.
    Do not make any assignments to \lstinline{fraction_string} -- this is a buffer that will be used later.
    The subsequent \function{sprintf()} call uses these variables to print the bit vector as a binary floating point value.

    \paragraph*{Check Your Work}

    Compile and run \texttt{\textbf{\textit{./floatlab}}}, trying a few values, starting with values whose IEEE~754 representation are easy to check.
    For example:

    \begin{verbatim}
        Enter a value, a two-operand arithmetic expression,
            "denormalize <value> <change exponent amount>",
            "renormalize <value> <change exponent amount>",
            or "quit": 1
        0x3f800000	+1.0000,0000,0000,0000,0000,000_{2} x 2^{0}

        Enter a value, ... or "quit": .25
        0x3e800000	+1.0000,0000,0000,0000,0000,000_{2} x 2^{-2}

        Enter a value, ... or "quit": 15.625
        0x417a0000	+1.1111,0100,0000,0000,0000,000_{2} x 2^{3}
    \end{verbatim}

    Try a few more on your own.
    You can also try creating some bit vectors to see that the sign, significand, and exponent are all what you expect, based on your understanding of the IEEE~754 format.
    For example:

    \begin{verbatim}
        Enter a value, ... or "quit": 0xF22AAAAA
        0xf22aaaaa	-1.0101,0101,0101,0101,0101,010_{2} x 2^{101}
    \end{verbatim}

    Don't forget to check subnormal numbers, too.
    For example:

    \begin{verbatim}
        Enter a value, ... or "quit": 5e-40
        0x000571cc	+0.0000,1010,1110,0011,1001,100_{2} x 2^{-126}
    \end{verbatim}

    \subsection{Normalizing and Denormalizing}

    You have three functions to write to manipulate floating point representations.

    \subsubsection{Denormalize}

    The \function{denormalize()} function converts an IEEE~754-compliant \lstinline{ieee754_t} value into a format that facilitate arithmetic.
    As described in Section~\ref{subsec:fpu.h}, the \lstinline{unnormal_t} structure that is returned by \function{denormalize()} has fields for the sign bit, the integer portion, the fractional portion, and the exponent.
    It also has flags for Not-a-Number and for Infinity.
    Unlike the IEEE~754 format, an \lstinline{unnormal_t} value can have more than one bit in its integer portion.

    There is no strictly-correct transformation of an \lstinline{ieee754_t} variable into an \lstinline{unnormal_t} variable (and so \function{denormalize()} will not be graded directly).
    The only requirement is that it be reversible;
    that is, this expression must be true: \lstinline{value == normalize(denormalize(value))}.

    We recommend that you place the ``ones'' bit ($2^0$) of the integer portion in the least significant bit of the \lstinline{integer_portion} field, the ``halves'' bit ($2^{-1}$) of the fractional portion in the most significant bit of the \lstinline{fractional_portion} field, as this will make it easier to adjust the exponent as needed.

    \paragraph*{Check Your Work}

    We have provided a function that will print a \lstinline{unnormal_t} value.
    When you run \texttt{\textbf{\textit{./floatlab}}}, you can specify that you want to denormalize a value, such as \texttt{\textbf{\textit{denormalize 12.375}}}.
    The program will then print the value, based on the \lstinline{unnormal_t} fields.
    Because there are 64 bits available for the integer portion and another 64 bits for the fractional portion, the \lstinline{unnormal_t} value will be printed in base-16:

    \begin{verbatim}
        Enter a value, a two-operand arithmetic expression,
            "denormalize <value> <change exponent amount>",
            "renormalize <value> <change exponent amount>",
            or "quit": denormalize 12.375
        +0000000000000001.8c00000000000000_{16} x 2^{3}
    \end{verbatim}

    Because $12.375_{10} = 1.1000,11_{2} \times 2^3$, we can see that $1.8\mathrm{C}_{16} \times 2^3$ is correct.
    (If you used the \lstinline{integer_portion} and/or \lstinline{fractional_portion} differently than we recommended, then your output will look different from this example).

    \subsubsection{Adjust\_Exponent}

    The \function{adjust_exponent()} function changes a \lstinline{unnormal_t} variable's exponent while preserving its value.
    For example, these values are all equal but have different exponents:
    \[
        1.1000,11_{2} \times 2^3 = 1,1000.11_{2} \times 2^{-1} = 0.0011,0001,1_{2} \times 2^6
    \]

    Write \function{adjust_exponent()} such that:
    \begin{itemize}
        \item A positive \lstinline{amount} causes the \lstinline{number}'s exponent to increase.
            The virtual binary point moves to the left by \lstinline{amount} by taking that many least significant bit(s) from the integer portion (right-shifting the other integer bits) and making it/them the most significant bit(s) in the fractional portion (right-shifting the existing fractional bits).
        \item A negative \lstinline{amount} causes the \lstinline{number}'s exponent to decrease.
            The virtual binary point moves to the right by \lstinline{-amount} by taking that many most significant bit(s) from the fractional portion (left-shifting the other fractional bits) and making it/them the least significant bit(s) in the integer portion (left-shifting the existing fractional bits).
    \end{itemize}

    You can now use \function{adjust_exponent()} to cause two values to have the same exponent, or you can use the function to align the significant bits.
    The \function{adjust_exponent()} function will not be graded directly.

    \paragraph*{Check Your Work}

    When you run \texttt{\textbf{\textit{./floatlab}}} and specify that you want to denormalize a value, you can also specify the amount by which you want to change the exponent.
    (The amount must be an integer value.) For example:

    \begin{verbatim}
        Enter ... "denormalize <value> <change exponent amount>", ...
            or "quit": denormalize 12.375 -4
        +0000000000000018.c000000000000000_{16} x 2^{-1}

        Enter ... "denormalize <value> <change exponent amount>", ...
            or "quit": denormalize 12.375 3
        +0000000000000000.3180000000000000_{16} x 2^{6}
    \end{verbatim}

    \subsubsection{Normalize}

    The \function{normalize()} function converts an \lstinline{unnormal_t} value into an IEEE~754-compliant format.
    The function stub already handles zero and the flagged cases of Not-a-Number and Infinity.
    The stub also handles the sign bit.

    Your task is to handle:
    \begin{itemize}
        \item Normal numbers, both those that already have exactly $1$ in the integer portion and those that need to be adjusted.
        \item Subnormal numbers, both those that can be directly converted and those that need to be adjusted.
        \item Cases that you will not be able to test until later:
        \begin{itemize}
            \item Numbers too great to be represented as normal numbers.
            \item Numbers too small to be represented as subnormal numbers.
            \item Rounding (when implemented, follow the IEEE~754 default of ``round-to-nearest-even.'')
        \end{itemize}
    \end{itemize}

    \paragraph*{Check Your Work}

    When you run \texttt{\textbf{\textit{./floatlab}}}, you can specify that you want to renormalize a value, such as \texttt{\textbf{\textit{renormalize 12.375}}} and \texttt{\textbf{\textit{renormalize 12.375 6}}}.
    The program will first denormalize the value.
    It will then adjust the exponent by the specified amount (if an amount is specified).
    Then it will send the result to \function{normalize()}.
    Finally, it will print the original value and the \lstinline{ieee754_t} value returned by \function{normalize}.

    For example:

    \begin{verbatim}
    Enter ... "renormalize <value> <change exponent amount>", ...
        or "quit": renormalize 12.375
    expected: 12.3750000000_{10}	0x41460000	+1.1000,1100,0000,0000,0000,000_{2} x 2^{3}
    actual:   12.3750000000_{10}	0x41460000	+1.1000,1100,0000,0000,0000,000_{2} x 2^{3}

    Enter ... "renormalize <value> <change exponent amount>", ...
        or "quit": renormalize 12.375 6
    expected: 12.3750000000_{10}	0x41460000	+1.1000,1100,0000,0000,0000,000_{2} x 2^{3}
    actual:   12.3750000000_{10}	0x41460000	+1.1000,1100,0000,0000,0000,000_{2} x 2^{3}

    Enter ... "renormalize <value> <change exponent amount>", ...
        or "quit": renormalize 0x00055000
    expected: 0.0000000000_{10}	0x00055000	+0.0000,1010,1010,0000,0000,000_{2} x 2^{-126}
    actual:   0.0000000000_{10}	0x00055000	+0.0000,1010,1010,0000,0000,000_{2} x 2^{-126}
    \end{verbatim}

    \subsection{Addition and Subtraction}

    As is the case for integer arithmetic, the heavy-lifting for addition and subtraction is handled solely by the \function{add()} function.
    The \function{subtract()} function is already implemented in terms of \function{add} and the \function{negate()} function.

    \subsubsection{Add}

    The \function{add()} stub identifies a handful of special cases that you can easily handle.
    After the guard clauses are handled, your task is to implement addition for two finite, non-zero numbers.

    Recall that for any number base, $b$, adding two floating point values $m_1 \times b^{e_1} + m_2 \times b^{e_2}$ is simplified when $e_1 = e_2$.

    Start by adjusting one of the denormalized operands so that the two denormalized operands have the same exponent.
    It is acceptable for the least significant bit (or even several less significant bits) to be truncated;
    however, \textit{you must take care that the most significant bit does not get truncated}!

    You now have two options:
    \begin{itemize}
        \item Use integer addition to add the fractional portions, use integer addition to add the integer portions, detect whether the fractional portion overflowed, and carry that 1 into the integer portion if the fractional portion did overflow.
        \item Adjust the two denormalized operands together until their significands are both fully in the integer portion or fully in the fractional portion.
            Make sure that, regardless of which field you chose, that that field's most significant bit is 0 for both operands, leaving room for a carry bit.
            Add the two operands together using integer addition.
    \end{itemize}

    \subsubsection{Negate}

    The \function{negate()} function is simple: it only needs to change the number's sign bit.

    \paragraph*{Check Your Work}

    When you run \texttt{\textbf{\textit{./floatlab}}}, you can enter a two-operand expression, such as addition and subtraction.
    As before, if an operand is prepended with \texttt{\textbf{\textit{0x}}} then the parser will treat it as a bit vector;
    otherwise, the parser will treat it as a floating point value.

    \begin{verbatim}
    Enter a value, a two-operand arithmetic expression,
        "denormalize <value> <change exponent amount>",
        "renormalize <value> <change exponent amount>",
        or "quit": 1 + 2
    0x3f800000	+1.0000,0000,0000,0000,0000,000_{2} x 2^{0}
    +
    0x40000000	+1.0000,0000,0000,0000,0000,000_{2} x 2^{1}
    expected: 3.0000000000_{10}	0x40400000	+1.1000,0000,0000,0000,0000,000_{2} x 2^{1}
    actual:   3.0000000000_{10}	0x40400000	+1.1000,0000,0000,0000,0000,000_{2} x 2^{1}
    \end{verbatim}

    Be sure to check:
    \begin{itemize}
        \item The identity and commutative properties
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{5 + 0}}}
            \item[] \texttt{\textbf{\textit{2 + 3}}}
            \item[] \texttt{\textbf{\textit{3 + 2}}}
        \end{itemize}
        \item Cases in which the exponent will be greater than that of either operand
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{3 + 3}}}
        \end{itemize}
        \item Fractional operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{.3 + .03}}}
        \end{itemize}
        \item Not only the use of negative operands, but also subtraction
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{-5 + 2}}}
            \item[] \texttt{\textbf{\textit{2 - 5}}}
            \item[] \texttt{\textbf{\textit{3 - -3}}}
        \end{itemize}
        \item Numbers both great and small
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{1.65e35 + 2.39e29}}}
            \item[] \texttt{\textbf{\textit{1.65e-39 + 2.39e-33}}}
        \end{itemize}
        \item A sufficiently-large sum overflows to infinity
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x7F7FFFFF + 0x73800000}}}
        \end{itemize}
        \item A sufficiently-small difference between normal numbers underflows to subnormal numbers
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x01000000 - 0x00C00000}}}
        \end{itemize}
        \item A number subtracted from itself produces zero:
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x00000001 - 0x00000001}}}
        \end{itemize}
        \item NaN and Infinity are ``sticky'' (except for $\infty - \infty$)
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{nan + 1}}}
            \item[] \texttt{\textbf{\textit{inf - 0x7F7FFFFF}}}
            \item[] \texttt{\textbf{\textit{inf - inf}}}
        \end{itemize}
    \end{itemize}

    \textit{Note: For the \function{add()} function, we will not deduct points if you have the wrong sign for Zero or for Not-a-Number} because the appropriate sign is usually indeterminate
    (There are two cases where the sign can be determined;
    can you discover which cases those are?)

    \paragraph*{Rounding}

    You can now check the rounding code in your \function{normalize()} implementation.

    \begin{itemize}
        \item When the rounded-off portion is less than halfway, you always round down
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x40000000 + 0x33FFFFFF}}}
            \item[] \texttt{\textbf{\textit{0x40000001 + 0x33FFFFFF}}}
        \end{itemize}
        \item When the rounded-off portion is more than halfway, you always round up
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x40000000 + 0x34000001}}}
            \item[] \texttt{\textbf{\textit{0x40000001 + 0x34000001}}}
        \end{itemize}
        \item When the rounded-off portion is exactly halfway, you round to the nearest-even
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x40000000 + 0x34000000}}}
            \item[] \texttt{\textbf{\textit{0x40000001 + 0x34000000}}}
        \end{itemize}
        \item Sometimes rounding can carry all the way to the integer portion, causing the exponent to change
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x407FFFFF + 0x34000000}}}
        \end{itemize}
    \end{itemize}

    \subsection{Multiplication and Division}

    Recall that for any number base, $b$, multiplying two floating point values $m_1 \times b^{e_1} + m_2 \times b^{e_2}$ produces $m_1 \cdot m_2 \times b^{e_1 + e_2}$.
    Similarly, dividing the two floating point values yields $\frac{m_1}{m_2} \times b^{e_1 - e_2}$.

    \subsubsection{Multiply}

    The \function{multiply()} stub identifies a handful of special cases that you can easily handle.
    After the guard clauses are handled, your task is to implement multiplication for two finite, non-zero numbers.

    While you have the option of performing integer multiplication without adjusting the denormalized operands (it would require only a little modification of your code from IntegerLab), we recommend that you adjust the denormalized operands so that you can use C's integer multiplication operator.
    Adjust the denormalized operands such that their significands are both fully in the integer portion or fully in the fractional portion.
    Because you do not need to give the two operands the same exponent, you do not need to worry about truncating bits.
    Instead, make sure that, regardless of which field you chose, all the significands' bits are in the lower 32 bits of that field -- this will leave enough bits for the full product.
    Multiply the two operands together using integer multiplication.

    \paragraph*{Check Your Work}

    Be sure to check:
    \begin{itemize}
        \item The identity, zero, and commutative properties
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{5 * 1}}}
            \item[] \texttt{\textbf{\textit{5 * 0}}}
            \item[] \texttt{\textbf{\textit{2 * 3}}}
            \item[] \texttt{\textbf{\textit{3 * 2}}}
        \end{itemize}
        \item Integer operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{75 * 7}}}
            \item[] \texttt{\textbf{\textit{5 * 25}}}
        \end{itemize}
        \item Fractional operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{.75 * 7}}}
            \item[] \texttt{\textbf{\textit{5 * .25}}}
        \end{itemize}
        \item Negative operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{-5 * 2}}}
            \item[] \texttt{\textbf{\textit{5 * -2}}}
            \item[] \texttt{\textbf{\textit{-5 * -2}}}
            \item[] \texttt{\textbf{\textit{5 * -0}}}
        \end{itemize}
        \item Numbers both great and small
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{1.65e25 * 2.39e11}}}
            \item[] \texttt{\textbf{\textit{1.65e-25 * 2.39e-11}}}
            \item[] \texttt{\textbf{\textit{1e-30 * 1e-8}}}
            \item[] \texttt{\textbf{\textit{2e30 * 2e-30}}}
        \end{itemize}
        \item A sufficiently-large product overflows to infinity
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x7E000000 * 0x41000000}}}
        \end{itemize}
        \item A sufficiently-small product underflows to zero
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{0x3C800000 * 0x00000020}}}
        \end{itemize}
        \item NaN and Infinity are ``sticky'' (except for $\infty \times 0$)
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{nan * 1}}}
            \item[] \texttt{\textbf{\textit{inf * 2}}}
            \item[] \texttt{\textbf{\textit{inf * 0}}}
        \end{itemize}
    \end{itemize}

    \subsubsection{Divide}

    Implementing the \function{divide()} function is very similar to implementing \function{multiply()} with three exceptions:

    \begin{itemize}
        \item There are different special cases
        \item You subtract the exponents and divide the significands
        \item Integer division is insufficient
    \end{itemize}

    We will limit our implementation of \function{divide()} to the special cases and to cases in which the dividend's significand is a multiple of the divisor's significand.
    In this limited implementation, integer division is sufficient.

    \paragraph*{Check Your Work}

    Be sure to check:
    \begin{itemize}
        \item The identity property
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{5 / 1}}}
        \end{itemize}
        \item Integer operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{75 / 4}}}
        \end{itemize}
        \item Fractional operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{.75 / 4}}}
            \item[] \texttt{\textbf{\textit{5 / .25}}}
            \item[] \texttt{\textbf{\textit{.75 / .25}}}
        \end{itemize}
        \item Negative operands
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{-4 / 2}}}
            \item[] \texttt{\textbf{\textit{4 / -2}}}
            \item[] \texttt{\textbf{\textit{-4 / -2}}}
        \end{itemize}
        \item Divisors that require more than one 1 in the significand (but the dividend's significand is still a multiple of the divisor's significand)
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{30 / 5}}}
            \item[] \texttt{\textbf{\textit{25 / 0x3F200000}}}
            \item[] \texttt{\textbf{\textit{0x3F480000 / 5}}}
        \end{itemize}
        \item The special cases
        \begin{itemize}
            \item[] \texttt{\textbf{\textit{nan / 2}}}
            \item[] \texttt{\textbf{\textit{2 / nan}}}
            \item[] \texttt{\textbf{\textit{inf / 2}}}
            \item[] \texttt{\textbf{\textit{0 / 2}}}
            \item[] \texttt{\textbf{\textit{2 / inf}}}
            \item[] \texttt{\textbf{\textit{2 / 0}}}
            \item[] \texttt{\textbf{\textit{inf / inf}}}
            \item[] \texttt{\textbf{\textit{0 / 0}}}
        \end{itemize}
    \end{itemize}

    \textit{Note}: For the \function{multiply()} and \function{divide()} functions, we will not deduct points if you have the wrong sign for Not-a-Number.
    \textit{We will, however, deduct points if you have the wrong sign for Zero.}


    \section{Turn-in and Grading}

    When you have completed this assignment, upload \textit{fpu.c} to
    \filesubmission.

    This assignment is worth 40 points. \\

    \begin{description}
        \rubricitem{1}{\function{is_nan()} correctly reports whether or not its argument is a number}
        \rubricitem{1}{\function{is_zero()} correctly reports whether or not its argument is zero}
        \rubricitem{1}{\function{is_infinity()} correctly reports whether or not its argument is infinite}
        \rubricitem{1}{\function{is_negative()} correctly reports whether or not its argument is negative}
        \rubricitem{2}{\function{ieee754_to_string()} correctly extracts the significand}
        \rubricitem{2}{\function{ieee754_to_string()} correctly extracts the exponent}
        \rubricitem{1}{\lstinline{value == normalize(denormalize(value))} holds true for unadjusted values}
        \rubricitem{1}{\lstinline{value == normalize(denormalize(value))} holds true for values with adjusted exponents}
        \rubricitem{1}{\function{negate()} correctly changes its argument's sign}
        \rubricitem{6}{\function{add()} can add integers \& fractions, positive \& negative values, and ``large'' \& ``small'' numbers}
        \rubricitem{2}{The identity and commutative properties hold for \function{add()}}
        \rubricitem{1}{\function{add()} provides correct answers for its special cases}
        \rubricitem{5}{\function{multiply()} can multiply integers \& fractions, positive \& negative values, and ``large'' \& ``small'' numbers}
        \rubricitem{3}{The identity, zero, and commutative properties hold for \function{multiply()}}
        \rubricitem{1}{\function{multiply()} provides correct answers for its special cases}
        \rubricitem{1}{\function{divide()} provides correct answers for its special cases}
        \rubricitem{1}{\function{divide()} can divide when the divisor is of the form $\pm 2^n, -126 \le n \le 127$}
        \rubricitem{1}{\function{divide()} can divide when the dividend's significand is a multiple of the divisor's significand}
        \rubricitem{1}{\function{add()} demonstrates that \function{normalize()} rounds down when the truncated part of the significand is less than halfway between representable values}
        \rubricitem{1}{\function{add()} demonstrates that \function{normalize()} rounds up when the truncated part of the significand is more than halfway between representable values}
        \rubricitem{2}{\function{add()} demonstrates that \function{normalize()} rounds to the nearest-even when the truncated part of the significand is exactly halfway between representable values}
        \rubricitem{1}{Rounding can carry into the exponent}
        \rubricitem{1}{\function{add()} and/or \function{multiply()} demonstrate that \function{normalize()} overflows to infinity}
        \rubricitem{1}{\function{add()}, \function{multiply()}, and/or \function{divide()} demonstrate that \function{normalize()} gracefully underflows through subnormal numbers}
        \rubricitem{1}{\function{multiply()} and/or \function{divide()} demonstrate that \function{normalize() underflows to zero}}
        \bonusitem{2}{\function{divide()} can divide arbitrary values}
    \end{description}

    \textbf{Penalties}
    \begin{description}
        \spaghetticodepenalties{1}
        \penaltyitem{1 (each)}{\function{is_nan()}, \function{is_zero()}, \function{is_infinity()}, \function{is_negative()}, and/or \function{negate()} use \lstinline{float} or \lstinline{double} variables or constants, use C's floating point operations, and/or a function you did not write}
        \penaltyitem{4}{\function{ieee754_to_string} uses \lstinline{float} or \lstinline{double} variables or constants, uses C's floating point operations, and/or uses a function you did not write (other than \function{sprintf()} and \function{bits_to_string()})}
        \penaltyitem{31}{\function{denormalize()}, \function{adjust_exponent()}, and/or \function{normalize()} use \lstinline{float} or \lstinline{double} variables or constants, use C's floating point operations, and/or a function you did not write}
        \item[] If \function{denormalize()}, \function{adjust_exponent()}, and \function{normalize()} are not penalized:
        \penaltyitem{9}{\function{add()} uses \lstinline{float} or \lstinline{double} variables or constants, uses C's floating point operations, and/or uses a function you did not write (other than \function{sprintf()} and \function{bits_to_string()})}
        \penaltyitem{9}{\function{multiply()} uses \lstinline{float} or \lstinline{double} variables or constants, uses C's floating point operations, and/or uses a function you did not write (other than \function{sprintf()} and \function{bits_to_string()})}
        \penaltyitem{3 (and no bonus)}{\function{divide()} uses \lstinline{float} or \lstinline{double} variables or constants, uses C's floating point operations, and/or uses a function you did not write (other than \function{sprintf()} and \function{bits_to_string()})}
        \end{description}


    \section{Epilogue}

    Lil enters the room.
    Herb challenges her: ``\textit{Gulliver's Travels}, `endian','' and Lil answers, ``ends.''

    Lil walks up to you and says, ``We have the insurance situation taken care of, and it's time to get the Zoo ready for guests.
    We're reassembling the tech team, and there's plenty of work to do.''

    You smile.
    ``That's good news!''

    Lil's face is hard to read.
    ``Well, yes and no.
    It's good that you'll be able to resume work on the Zoo's systems.
    But while Archie was waiting for us to fix the insurance situation, he picked up a book on assembly code.
    He has some ideas.
    There's another `opportunity to succeed' waiting for you.''

    \textit{To be continued...}

\end{document}
