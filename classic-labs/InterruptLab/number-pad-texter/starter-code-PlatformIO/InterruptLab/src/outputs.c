/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file outputs.c
 *
 * @author (SAMPLE SOLUTION)
 *
 * @brief Functions to display the message editor's contents and to send the
 *      message to the host computer.
 *
 ******************************************************************************/

/*
 * InterruptLab (c) 2021-23 Christopher A. Bohn
 * Number Pad Texter (c) 2023 Christopher A. Bohn
 *
 * Assignment and starter code licensed under the Apache License,
 * Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <CowPi.h>
#include <string.h>
#include "outputs.h"

static FILE *display;


/**
 * Configures the display module, along with the rest of the Cow Pi hardware.
 */
void initialize_display(void) {
    display = cowpi_setup(9600,
                          (cowpi_display_module_t) {.display_module = LCD_CHARACTER},
                          (cowpi_display_module_protocol_t) {.protocol = I2C, .i2c_address = cowpi_discover_i2c_address(SDA, SCL)}
    );
    if (display == NULL) {
        int i2c_configuration_line = __LINE__ - 3;
        fprintf_P(stderr, PSTR("Display was not configured!\n ***"));
        int8_t i2c_address = cowpi_discover_i2c_address(SDA, SCL);
        if (i2c_address == 0) {
            fprintf_P(stderr, PSTR("No I2C device detected.\n"));
        } else if (i2c_address == -1) {
            fprintf_P(stderr, PSTR("Multiple I2C devices detected.\n"));
            fprintf_P(stderr, PSTR("Modify line %d to hard-code the correct I2C address.\n"), i2c_configuration_line);
        } else {
            fprintf_P(stderr, PSTR("This does not appear to be an I2C problem.\n"));
        }
        fprintf_P(stderr, PSTR("\nRe-assigning display module's output to the console\n"));
        fprintf_P(stderr, PSTR("so that you can work on other parts of the assignment.\n\n"));
        display = stdout;
    }
}

/**
 * Sends the message to the host computer, simulating the transmission of an SMS message.
 * @param message The string to be sent to the host computer
 * @param maximum_message_length An upper bound on the length of the buffer (including the terminal NUL)
 */
void transmit_message(char message[], int8_t maximum_message_length) {
    size_t actual_message_length = strlen(message);
    // replace boxes with spaces
    message[maximum_message_length - 1] = '\0';
    char *box_character;
    while ((box_character = memchr(message, 0xDB, maximum_message_length))) {
        *box_character = ' ';
    }
    // send the message to the Serial Monitor
    printf_P(PSTR("Message is %d characters, starting at %p\n"), actual_message_length, message);
    printf_P(PSTR("%s\n"), message);
}

/**
 * Displays up to 16 characters on the display's top row, along with a carat as the cursor on the bottom row.
 * @param message The start of the string to be displayed
 * @param cursor_position The column in which the carat should be placed; 0 is the leftmost column and 15 is the rightmost column
 */
void update_display(const char message[], int8_t cursor_position) {
    // the message
    fprintf(display, "%-16.16s\n", message);
    // the cursor
            // printf can't do variable-width conversions on AVR targets, so we'll insert one space at a time
    for (int8_t i = 0; i < cursor_position; i++) {
        fprintf(display, " ");
    }
    fprintf(display, "^\n\f");
}
