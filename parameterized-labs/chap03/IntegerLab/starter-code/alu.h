/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file alu.h
 *
 * @author Christopher A. Bohn
 *
 * @brief Function prototypes, macros, and type declarations for IntegerLab.
 *
 ******************************************************************************/

/*
 * IntegerLab (c) 2018-24 Christopher A. Bohn
 *
 * Starter code licensed under the Apache License, Version 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */

#ifndef ALU_H
#define ALU_H

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

typedef struct {
    uint8_t a       : 1;
    uint8_t b       : 1;
    uint8_t c_in    : 1;
    uint8_t sum     : 1;
    uint8_t c_out   : 1;
} one_bit_adder_t;

typedef struct {
    uint16_t result;
    uint16_t supplemental_result;
    uint8_t unsigned_overflow   : 1;
    uint8_t signed_overflow     : 1;
    uint8_t divide_by_zero      : 1;
} alu_result_t;

/*
 * PREDEFINED MACROS THAT DO NOT DEPEND ON STUDENT CODE
 */

#define is_zero(number)     (!(number))
#define is_not_zero(number) (!!(number))

/*
 * UTILITY FUNCTIONS
 */

uint32_t exponentiate(int exponent);
int lg(uint32_t power_of_two);
bool is_negative(uint16_t value);

/*
 * LOGICAL BOOLEAN FUNCTIONS
 */

bool logical_not(uint32_t value);
bool logical_and(uint32_t value1, uint32_t value2);
bool logical_or(uint32_t value1, uint32_t value2);

/*
 * ARITHMETIC BUILDING BLOCKS
 */

one_bit_adder_t one_bit_full_addition(one_bit_adder_t bits);
uint32_t ripple_carry_addition(uint32_t value1, uint32_t value2, uint8_t initial_carry_in);
uint32_t multiply_by_power_of_two(uint16_t value, uint16_t power_of_two);

/*
 * ARITHMETIC FUNCTIONS
 */

alu_result_t add(uint16_t augend, uint16_t addend);
alu_result_t subtract(uint16_t menuend, uint16_t subtrahend);
alu_result_t unsigned_multiply(uint16_t multiplicand, uint16_t multiplier);
alu_result_t signed_multiply(uint16_t multiplicand, uint16_t multiplier);
alu_result_t unsigned_divide(uint16_t dividend, uint16_t divisor);
alu_result_t signed_divide(uint16_t dividend, uint16_t divisor);

/*
 * COMPARISON FUNCTIONS
 */

bool equal(uint16_t value1, uint16_t value2);
bool not_equal(uint16_t value1, uint16_t value2);

/**
 * Determines whether the first value is strictly less than the second, when interpreted as two's complement values.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is strictly less than the second; 0 otherwise
 */
static inline bool signed_less_than(uint16_t value1, uint16_t value2) {
    static int recursion_depth = 0;
    if (recursion_depth > 0) {
        fprintf(stderr, "[ERROR] Mutual recursion detected in comparison function! Aborting comparison.\n");
        recursion_depth--;
        return false;
    }
    recursion_depth++;
    alu_result_t comparison = subtract(value1, value2);
    recursion_depth--;
    return is_negative(comparison.result) ^ comparison.signed_overflow;
}

/**
 * Determines whether the first value is at most the second; that is, whether the first value is less than or equal to
 * the second, when interpreted as two's complement values.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is at most the second; 0 otherwise
 */
static inline bool signed_at_most(uint16_t value1, uint16_t value2) {
    static int recursion_depth = 0;
    if (recursion_depth > 0) {
        fprintf(stderr, "[ERROR] Mutual recursion detected in comparison function! Aborting comparison.\n");
        recursion_depth--;
        return false;
    }
    recursion_depth++;
    alu_result_t comparison = subtract(value1, value2);
    recursion_depth--;
    return logical_or(is_negative(comparison.result) ^ comparison.signed_overflow, is_zero(comparison.result));
}

/**
 * Determines whether the first value is at least the second; that is, whether the first value is greater than or equal
 * to the second, when interpreted as two's complement values.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is at least the second; 0 otherwise
 */
static inline bool signed_at_least(uint16_t value1, uint16_t value2) {
    return logical_not(signed_less_than(value1, value2));
}

/**
 * Determines whether the first value is strictly greater than the second, when interpreted as two's complement values.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is strictly greater than the second; 0 otherwise
 */
static inline bool signed_greater_than(uint16_t value1, uint16_t value2) {
    return logical_not(signed_at_most(value1, value2));
}

/**
 * Determines whether the first value is strictly less than the second, when interpreted as unsigned integers.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is strictly less than the second; 0 otherwise
 */
static inline bool unsigned_less_than(uint16_t value1, uint16_t value2) {
    static int recursion_depth = 0;
    if (recursion_depth > 0) {
        fprintf(stderr, "[ERROR] Mutual recursion detected in comparison function! Aborting comparison.\n");
        recursion_depth--;
        return false;
    }
    recursion_depth++;
    alu_result_t comparison = subtract(value1, value2);
    recursion_depth--;
    return comparison.unsigned_overflow;
}

/**
 * Determines whether the first value is at most the second; that is, whether the first value is less than or equal to
 * the second, when interpreted as unsigned integers.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is at most the second; 0 otherwise
 */
static inline bool unsigned_at_most(uint16_t value1, uint16_t value2) {
    static int recursion_depth = 0;
    if (recursion_depth > 0) {
        fprintf(stderr, "[ERROR] Mutual recursion detected in comparison function! Aborting comparison.\n");
        recursion_depth--;
        return false;
    }
    recursion_depth++;
    alu_result_t comparison = subtract(value1, value2);
    recursion_depth--;
    return logical_or(comparison.unsigned_overflow, is_zero(comparison.result));
}

/**
 * Determines whether the first value is at least the second; that is, whether the first value is greater than or equal
 * to the second, when interpreted as unsigned integers.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is at least the second; 0 otherwise
 */
static inline bool unsigned_at_least(uint16_t value1, uint16_t value2) {
    return logical_not(unsigned_less_than(value1, value2));
}

/**
 * Determines whether the first value is strictly greater than the second, when interpreted as unsigned integers.
 * @param value1 the value on the left side of the inequality comparison
 * @param value2 the value on the right side of the inequality comparison
 * @return 1 if the first argument is strictly greater than the second; 0 otherwise
 */
static inline bool unsigned_greater_than(uint16_t value1, uint16_t value2) {
    return logical_not(unsigned_at_most(value1, value2));
}

#endif //ALU_H