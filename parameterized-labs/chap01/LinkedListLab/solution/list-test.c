/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file list-test.c
 *
 * @author Christopher A. Bohn
 *
 * @brief Functions for testing the list code (should work with both
 *      arraylist and linkedlist).
 *
 ******************************************************************************/

/*
 * LinkedListLab (c) 2021-25 Christopher A. Bohn
 *
 * Starter code licensed under the Apache License, Version 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "list-test.h"
#include "list.h"
#include "word_entry.h"

static int select_function(char const *function_names[], int number_of_functions) {
    char buffer[80];
    int option;
    do {
        int i = -1;
        while (++i < number_of_functions) {
            printf("%2d) %-26s", i, function_names[i]);
            if (++i < number_of_functions)
                printf("%2d) %-21s", i, function_names[i]);
            if (++i < number_of_functions)
                printf("%2d) %-21s", i, function_names[i]);
            printf("\n");
        }
        printf("Select the function you wish to check: ");
        scanf("%79s", buffer);
        option = (int) strtol(buffer, NULL, 10);
        if (option == 0 && errno == EINVAL) {
            printf("Invalid choice (%s). Please select a number between 0 and %d.\n\n", buffer, number_of_functions);
            errno = 0;
            option = -1;
        } else if (option < 0 || option > number_of_functions) {
            printf("Invalid choice %d. Please select a choice between 0 and %d.\n\n", option, number_of_functions);
        } else {}
    } while (option < 0 || option > number_of_functions);
    return (int) option;
}

void test_list(void) {
    enum {
        RETURN_TO_MAIN_MENU = 0,
        CREATE_LIST,
        DESTROY_LIST,
        GET_ITERATOR,
        GET_LIST,
        HAS_NEXT,
        HAS_PREVIOUS,
        ITERATE_NEXT,
        ITERATE_PREVIOUS,
        PREPEND,
        APPEND,
        INSERT,
        DELETE,
        GET_WORD_ENTRY,
        GET_NEXT_WORD_ENTRY,
        GET_PREVIOUS_WORD_ENTRY,
        SWAP_NEXT,
        SWAP_PREVIOUS,
        MERGE_NEXT,
        MERGE_PREVIOUS,
        NUMBER_OF_LIST_FUNCTIONS
    };
    printf("\nTesting list functions...\n");
    char const *function_names[NUMBER_OF_LIST_FUNCTIONS + 1] = {
            "Return to main menu",
            "create_list()",
            "destroy_list()",
            "get_iterator()",
            "get_list()",
            "has_next()",
            "has_previous()",
            "iterate_next()",
            "iterate_previous()",
            "prepend()",
            "append()",
            "insert()",
            "delete()",
            "get_word_entry()",
            "get_next_word_entry()",
            "get_previous_word_entry()",
            "swap_next()",
            "swap_previous()",
            "merge_next()",
            "merge_previous()",
    };
    char buffer[80];
    word_entry_t *word_entry = NULL;
    list_t *list = NULL;
    iterator_t *iterator = NULL;
    int option = select_function(function_names, NUMBER_OF_LIST_FUNCTIONS);
    printf("\n");
    while (option) {
        switch (option) {
            case CREATE_LIST:
                printf("Creating list.\n");
                list = create_list();
                printf("Created list at %p.\n", list);
                print(list);
                break;
            case DESTROY_LIST:
                printf("Destroying list.\n");
                if (list == NULL) {
                    printf("There is no list to destroy.\n");
                } else {
                    destroy_list(list, true);
                }
                break;
            case GET_ITERATOR:
                printf("Retrieving iterator from list at %p.\n", list);
                iterator = get_iterator(list);
                if (!iterator) {
                    printf("get_iterator() returned NULL.\n");
                } else {
                    printf("Iterator successfully retrieved at %p.\n", iterator);
                }
                print(list);
                break;
            case GET_LIST:
                printf("Retrieving list for iterator at %p.\n", iterator);
                printf("Expected list at %p.\n", list);
                list = get_list(iterator);
                printf("List actually at %p.\n", list);
                break;
            case HAS_NEXT:
                printf("The iterator ");
                fflush(stdout);
                printf(has_next(iterator) ? "has" : "does not have");
                printf(" a next element.\n");
                break;
            case HAS_PREVIOUS:
                printf("The iterator ");
                fflush(stdout);
                printf(has_previous(iterator) ? "has" : "does not have");
                printf(" a previous element.\n");
                break;
            case ITERATE_NEXT:
                printf("Iterating forward.\n");
                iterator = iterate_next(iterator);
                print(list);
                break;
            case ITERATE_PREVIOUS:
                printf("Iterating backward.\n");
                iterator = iterate_previous(iterator);
                print(list);
                break;
            case PREPEND:
                printf("Prepending word_entry. First we need a word_entry. Enter a word: ");
                scanf("%79s", buffer);
                word_entry = create_word_entry(buffer);
                if (get_count(word_entry) == 0) { increment_count(word_entry); }
                printf("Created --     %s\n", word_entry_to_string(buffer, word_entry));
                printf("Now prepending:\n");
                iterator = prepend(list, word_entry);
                print(list);
                break;
            case APPEND:
                printf("Appending word_entry. First we need a word_entry. Enter a word: ");
                scanf("%79s", buffer);
                word_entry = create_word_entry(buffer);
                if (get_count(word_entry) == 0) { increment_count(word_entry); }
                printf("Created --     %s\n", word_entry_to_string(buffer, word_entry));
                printf("Now appending:\n");
                iterator = append(list, word_entry);
                print(list);
                break;
            case INSERT:
                printf("Inserting word_entry. First we need a word_entry. Enter a word: ");
                scanf("%79s", buffer);
                word_entry = create_word_entry(buffer);
                if (get_count(word_entry) == 0) { increment_count(word_entry); }
                printf("Created --     %s\n", word_entry_to_string(buffer, word_entry));
                printf("Now inserting:\n");
                list = insert(iterator, word_entry);
                print(list);
                break;
            case DELETE:
                printf("Deleting element\n");
                list = delete(iterator, true);
                print(list);
                break;
            case GET_WORD_ENTRY:
                printf("Getting word entry: ");
                fflush(stdout);
                printf("%s\n", word_entry_to_string(buffer, get_word_entry(iterator)));
                break;
            case GET_NEXT_WORD_ENTRY:
                printf("Getting next word entry: ");
                fflush(stdout);
                printf("%s\n", word_entry_to_string(buffer, get_next_word_entry(iterator)));
                break;
            case GET_PREVIOUS_WORD_ENTRY:
                printf("Getting previous word entry: ");
                fflush(stdout);
                printf("%s\n", word_entry_to_string(buffer, get_previous_word_entry(iterator)));
                break;
            case SWAP_NEXT:
                printf("Swapping %s", word_entry_to_string(buffer, get_word_entry(iterator)));
                printf(" and %s\n", word_entry_to_string(buffer, get_next_word_entry(iterator)));
                iterator = swap_next(iterator);
                print(list);
                break;
            case SWAP_PREVIOUS:
                printf("Swapping %s", word_entry_to_string(buffer, get_word_entry(iterator)));
                printf(" and %s\n", word_entry_to_string(buffer, get_previous_word_entry(iterator)));
                iterator = swap_previous(iterator);
                print(list);
                break;
            case MERGE_NEXT:
                printf("Merging %s", word_entry_to_string(buffer, get_word_entry(iterator)));
                printf(" and %s\n", word_entry_to_string(buffer, get_next_word_entry(iterator)));
                iterator = merge_next(iterator);
                print(list);
                break;
            case MERGE_PREVIOUS:
                printf("Merging %s", word_entry_to_string(buffer, get_word_entry(iterator)));
                printf(" and %s\n", word_entry_to_string(buffer, get_previous_word_entry(iterator)));
                iterator = merge_previous(iterator);
                print(list);
                break;
            default:
                // include this here in case we change NUMBER_OF_LIST_FUNCTIONS without adding all the required cases
                fprintf(stderr, "Reached unreachable code with option value %d (file %s, line %d in function %s).\n",
                        option, __FILE__, __LINE__, __func__);
        }
        printf("\n");
        option = select_function(function_names, NUMBER_OF_LIST_FUNCTIONS);
        printf("\n");
    }
    printf("Returning to main menu.\n\n");
}
