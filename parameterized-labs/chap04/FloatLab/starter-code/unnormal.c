/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file unnormal.c
 *
 * @author Christopher A. Bohn
 *
 * @brief @copybrief unnormal.h
 *
 ******************************************************************************/

/*
 * FloatLab (c) 2019-23 Christopher A. Bohn
 *
 * Starter code licensed under the Apache License, Version 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "unnormal.h"

static const uint64_t LSB = ((uint64_t) 0x1);
static const uint64_t MSB = (((uint64_t) 0x1) << 63);
static const uint64_t MSB_OF_LOWER_HALF = (((uint64_t) 0x1) << 31);
// static const uint64_t LOWER_THIRTY_TWO_BITS = (uint64_t) 0xFFFFFFFF;
static const uint64_t UPPER_THIRTY_TWO_BITS = (uint64_t) 0xFFFFFFFF00000000uL;
static const uint64_t SIGNIFICANT_FRACTION_BITS = (uint64_t) 037777777;


#define assign_static_warnings(value) do {                          \
        (value).warnings = NO_WARNING;                              \
        if ((value).fraction) {                                     \
            (value).warnings |= MULTIPLICATION_IS_NOT_RECOMMENDED;  \
        }                                                           \
        if ((value).integer & UPPER_THIRTY_TWO_BITS) {              \
            (value).warnings |= MULTIPLICATION_IS_UNRELIABLE;       \
        }                                                           \
        if ((value).integer & MSB) {                                \
            (value).warnings |= ADDITION_IS_UNRELIABLE;             \
        }                                                           \
    } while (0)

static inline bool value_is_special(unnormal_t value) { return value.is_infinite || value.is_not_a_number; }

static inline bool significand_is_zero(unnormal_t value) { return !value.integer && !value.fraction; }


unnormal_t _create_unnormal(unnormal_t *args) {
    unnormal_t result = {
            .sign = args->sign,
            .integer = args->integer,
            .fraction = args->fraction,
            .exponent = args->exponent,
            .is_infinite = args->is_infinite,
            .is_not_a_number = args->is_not_a_number,
    };
    assign_static_warnings(result);
    if (!value_is_special(result)                           // if it's infinity or NaN, the significand is meaningless
        && result.integer                                   // if integer portion is 0, anything in fraction is possible
        && (result.fraction & SIGNIFICANT_FRACTION_BITS) && // if there are 1s in the lower-order bits
        !(result.fraction & ~SIGNIFICANT_FRACTION_BITS)) {  //      and none in the higher-order bits, then
        result.warnings |= IMPROBABLE_VALUE;                //      the student probably forgot to shift the fraction
    }
    return result;
}

char *unnormal_to_string(char *destination, unnormal_t number) {
    if (number.is_infinite) {
        sprintf(destination, "%cInfinity", number.sign ? '-' : '+');
    } else if (number.is_not_a_number) {
        sprintf(destination, "%cNot a Number", number.sign ? '-' : '+');
    } else {
        sprintf(destination, "%c%016lx.%016lx_{16} x 2^{%d}",
                number.sign ? '-' : '+', number.integer, number.fraction, number.exponent);
    }
    return destination;
}

uint8_t get_sign(unnormal_t number) {
    return number.sign;
}

uint64_t get_integer(unnormal_t number) {
    return number.integer;
}

uint64_t get_fraction(unnormal_t number) {
    return number.fraction;
}

int16_t get_exponent(unnormal_t number) {
    return (int16_t) number.exponent;
}

bool is_infinite(unnormal_t number) {
    return number.is_infinite;
}

bool is_not_a_number(unnormal_t number) {
    return number.is_not_a_number;
}

bool has_no_warnings(unnormal_t number) {
    return number.warnings == NO_WARNING;
}

bool has_unspecified_warning(unnormal_t number) {
    return !!(number.warnings & OTHER);
}

bool multiplication_is_not_recommended(unnormal_t number) {
    return !!(number.warnings & MULTIPLICATION_IS_NOT_RECOMMENDED);
}

bool multiplication_is_unreliable(unnormal_t number) {
    return !!(number.warnings & MULTIPLICATION_IS_UNRELIABLE);
}

bool addition_is_unreliable(unnormal_t number) {
    return !!(number.warnings & ADDITION_IS_UNRELIABLE);
}

bool shift_overflowed(unnormal_t number) {
    return !!(number.warnings & SHIFT_OVERFLOWED);
}

bool shift_underflowed(unnormal_t number) {
    return !!(number.warnings & SHIFT_UNDERFLOWED);
}

bool operation_was_not_performed(unnormal_t number) {
    return !!(number.warnings & REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED);
}

bool created_number_is_improbable(unnormal_t number) {
    return !!(number.warnings & IMPROBABLE_VALUE);
}

unnormal_t shift_left_once(unnormal_t number) {
    unnormal_t result = {
            .sign = number.sign,
            .is_infinite = number.is_infinite,
            .is_not_a_number = number.is_not_a_number,
    };
    result.integer = number.integer << 1;
    if (number.fraction & MSB) {
        result.integer |= LSB;
    }
    result.fraction = number.fraction << 1;
    result.exponent = number.exponent - 1;
    assign_static_warnings(result);
    if (number.integer & MSB) {
        result.warnings |= SHIFT_OVERFLOWED;
    }
    return result;
}

unnormal_t shift_right_once(unnormal_t number) {
    unnormal_t result = {
            .sign = number.sign,
            .is_infinite = number.is_infinite,
            .is_not_a_number = number.is_not_a_number,
    };
    result.fraction = number.fraction >> 1;
    if (number.integer & LSB) {
        result.fraction |= MSB;
    }
    result.integer = number.integer >> 1;
    result.exponent = number.exponent + 1;
    assign_static_warnings(result);
    if (number.fraction & LSB) {
        result.warnings |= SHIFT_UNDERFLOWED;
    }
    return result;
}

unnormal_t shift_left(unnormal_t number, int16_t amount) {
    unnormal_t result = number;
    if (amount < 0) {
        assign_static_warnings(result);
        result.warnings |= REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED;
        return result;
    }
    unnormal_warning_t warning = NO_WARNING;
    for (int16_t i = 0; i < amount; i++) {
        result = shift_left_once(result);
        if (shift_overflowed(result)) {
            warning |= SHIFT_OVERFLOWED;
        }
    }
    assign_static_warnings(result);
    result.warnings |= warning;
    return result;
}

unnormal_t shift_right(unnormal_t number, int16_t amount) {
    unnormal_t result = number;
    if (amount < 0) {
        assign_static_warnings(result);
        result.warnings |= REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED;
        return result;
    }
    unnormal_warning_t warning = NO_WARNING;
    for (int16_t i = 0; i < amount; i++) {
        result = shift_right_once(result);
        if (shift_underflowed(result)) {
            warning |= SHIFT_UNDERFLOWED;
        }
    }
    assign_static_warnings(result);
    result.warnings |= warning;
    return result;
}

unnormal_t place_all_bits_in_integer(unnormal_t number) {
    unnormal_t result = number;
    if (value_is_special(result) || significand_is_zero(result)) {
        assign_static_warnings(result);
        return result;
    }
    unnormal_warning_t warning = NO_WARNING;
    while (result.fraction) {
        result = move_binary_point_to_the_right(result);
        if (shift_overflowed(result)) {
            warning |= SHIFT_OVERFLOWED;
        }
    }
    while (!(result.integer & LSB)) {
        result = move_binary_point_to_the_left(result);
        if (shift_underflowed(result)) {                // really shouldn't be possible
            warning |= SHIFT_UNDERFLOWED;
        }
    }
    assign_static_warnings(result);
    result.warnings |= warning;
    return result;
}

unnormal_t set_integer(unnormal_t number, uint32_t integer) {
    unnormal_t result = number;
    if (value_is_special(result)) {
        assign_static_warnings(result);
        result.warnings |= REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED;
        return result;
    }
    unnormal_warning_t warning = NO_WARNING;
    while (result.integer < integer) {
        result = move_binary_point_to_the_right(result);
        if (shift_overflowed(result)) {                 // really shouldn't be possible
            warning |= SHIFT_OVERFLOWED;
        }
    }
    while (result.integer > integer) {
        result = move_binary_point_to_the_left(result);
        if (shift_underflowed(result)) {
            warning |= SHIFT_UNDERFLOWED;
        }
    }
    if (result.integer != integer) {
        result = number;
        assign_static_warnings(result);
        result.warnings |= REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED;
    } else {
        assign_static_warnings(result);
        result.warnings |= warning;
    }
    return result;
}

unnormal_t set_exponent(unnormal_t number, int16_t exponent) {
    unnormal_t result = number;
    if (value_is_special(result)) {
        assign_static_warnings(result);
        result.warnings |= REQUESTED_OPERATION_COULD_NOT_BE_PERFORMED;
        return result;
    }
    unnormal_warning_t warning = NO_WARNING;
    while (result.exponent > exponent) {
        result = decrement_exponent(result);
        if (shift_overflowed(result)) {
            warning |= SHIFT_OVERFLOWED;
        }
    }
    while (result.exponent < exponent) {
        result = increment_exponent(result);
        if (shift_underflowed(result)) {
            warning |= SHIFT_UNDERFLOWED;
        }
    }
    assign_static_warnings(result);
    result.warnings |= warning;
    return result;
}

bool fraction_will_carry_into_integer_on_addition(unnormal_t addend, unnormal_t augend) {
    return (addend.fraction + augend.fraction < addend.fraction);
}

bool fraction_will_borrow_from_integer_on_subtraction(unnormal_t menuend, unnormal_t subtrahend) {
    return (subtrahend.fraction > menuend.fraction);
}

bool left_shift_will_make_multiplication_unreliable(unnormal_t number) {
    if (multiplication_is_unreliable(number)) {
        return true;
    }
    return (number.integer & MSB_OF_LOWER_HALF);
}

bool left_shift_will_make_addition_unreliable(unnormal_t number) {
    if (addition_is_unreliable(number)) {
        return true;
    }
    return (number.integer & (MSB >> 1));
}
