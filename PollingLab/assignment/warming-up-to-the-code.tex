Locate the \lstinline{keys} $4 \times 4$ nested array on lines 72--77 of \textit{number\_builder.ino}.
This nested array serves as a lookup table to obtain the appropriate value when a key is pressed.
\textit{Even the starter code depends on this nested array being populated correctly.}
The element \lstinline{keys[0][0]} will correspond to the \texttt{1} key;
\lstinline{keys[0][3]} will correspond to the \texttt{A} key;
\lstinline{keys[3][0]} will correspond to the \texttt{*} key;
and \lstinline{keys[3][3]} will correspond to the \texttt{D} key.

We want the numerals \texttt{0}-\texttt{9} to produce their respective decimal
(and hexadecimal) values. We want \texttt{A}-\texttt{D} to produce their
respective hexadecimal values. We want \texttt{\#} to produce the hexadecimal
value 0xE, and we want \texttt{*} to produce the hexadecimal value 0xF.

\begin{itemize}
    \item Populate \lstinline{keys}' nested array initializer so that the
        lookup table will produce the correct value for each row/column
        combination.
\end{itemize}

You can confirm that you correctly populated the array's initializer by running the test code.
Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}:

\begin{lstlisting}
void loop() {
  test_io();
  // build_number();
}
\end{lstlisting}

Upload the program to your \developmentboard.
The test code will output on both the Serial Monitor and on the display module.
The output will include the key that was pressed (if any), a hyphen if no key is being pressed, or a question mark if \function{get_keypress()} returns an invalid value.

\begin{lstlisting}
    ...
    char key_character;
    if (key_pressed <= 9) {
      key_character = key_pressed + '0';
    } else if (0xA <= key_pressed && key_pressed <= 0xF) {
      key_character = key_pressed - 0xA + 'A';
    } else if (key_pressed == 0xFF) {
      key_character = '-';
    } else {
      key_character = '?';
    }
    ...
\end{lstlisting}

Familiarize yourself with the test code's other outputs.
The output will include the positions of the left and right buttons (``U'' for up and ``D'' for down) and of the left and right switches (``L'' for left position and ``R'' for right position).

\begin{lstlisting}
    ...
    left_button_position ? 'D' : 'U', right_button_position ? 'D' : 'U',
    left_switch_position ? 'R' : 'L', right_switch_position ? 'R' : 'L'
    ...
\end{lstlisting}

Finally, if both buttons are pressed then the left LED will illuminate, and if both switches are in the right position then the right LED will illuminate.

\begin{lstlisting}
    ...
    set_left_led(left_button_position && right_button_position);
    set_right_led(left_switch_position && right_switch_position);
    ...
\end{lstlisting}


\section{Debouncing} \label{sec:debouncing}

Mechanical buttons and switches demonstrate a phenomenon called \textit{switch bounce}.
This causes voltage to fluctuate for hundreds of microseconds when the contacts close or open.
When this fluctuation is in the indeterminate region between the logical low and high thresholds, it can cause the logic level to ``bounce'' back-and-forth between high and low until settling into the final, correct logic level.
This causes the digital circuitry or software to ``see'' multiple triggering events.

A traditional way to debounce is to introduce a simple low-pass filter using a resistor and a capacitor.
Other common hardware-based approaches use digital feedbck circuits.

Hardware design can be simplified by solving a hardware problem with software, and so you will often see hobby projects with ``debouncing code'' such as \lstinline{delay(20);} that pauses execution between detecting the first change of the button's or switch's position and acting upon it for 20ms, ample time for switch bounce to stabilize. The problem (beyond \function{delay()} being disallowed in this lab) is that 20ms is a long time to leave your system completely non-responsive.

The solution you will use allows your system to continue to respond to other external events. For example, you can press both buttons at very nearly the same time (or, unlikely, at the exact same time) and the software will react to both immediately.

Briefly examine the starter code's implementation of \function{get_keypress()}.
Notice that there are two \lstinline{static} variables,\footnote{
    A function-local variable modified with the \lstinline{static} keyword is allocated on the heap but remains scope-limited to that function.
    Its initializer runs only once, and then its value is preserved between calls to that function.}
one to remember the last time that a true keypress was detected, and one to remember the last value read from the keypad.
If fewer than 20ms have passed since the last true keypress, then the keypress that was detected is due to switch bounce, and so the function simply returns the last value read from the keypad.
If more than 20ms have passed, then we know that this is a new keypress, and so both of these variables are updated.