In this section you will implement a ``number builing tool'' that turns a sequence of inputs into a number.
A notional use of this number builder would be to create the operands for a calculator.
Section~\ref{subsec:functionalspecification} has the tool's specification.
You should design your system using the I/O functions in \textit{io\_functions.c} -- either the implementations from the starter code, or the implementations you wrote (or will write) from Section~\ref{sec:MemMapIO}.
After the specification are a few suggestions for making good use of those functions.

\textit{Remember that to start your simple embedded system, the \textbf{left switch} must be in the \underline{left} position when the \developmentboard\ restarts.}

You can complete this part of the assignment before or after implementing the I/O code from Section~\ref{sec:MemMapIO}.
You must, however, complete Section~\ref{sec:LabTime} first.
If you have already implemented the I/O code from Section~\ref{sec:MemMapIO}, you may want to make a backup copy of your program now.


\subsection{Number Builder Specification} \label{subsec:functionalspecification}

%! suppress = LabelConvention
\begin{enumerate}
    \item The tool shall have two alignment modes, \textit{left justified mode} and \textit{right justified mode}. The \textbf{left switch} controls the alignment mode.
        When the \textbf{left switch} is toggled to the left, the tool shall be in left justified mode.
        When the \textbf{left switch} is toggled to the right, the tool shall be in right justified mode.
    \item The tool shall have two number bases, \textit{decimal} and \textit{hexadecimal}.
        The \textbf{right switch} controls the number base.
    \item \label{spec:decimalExplained} When the \textbf{right switch} is toggled to the left, the number builder will use the decimal number base.
        When the user presses a button on the \textbf{matrix keypad} with a decimal numeral (\textit{0-9}) then the number builder shall take the appropriate action as specified in requirement~\ref{spec:initialKeyPress} or \ref{spec:BuildingValue}.
        Any other buttons on the keypad shall be ignored.
    \item \label{spec:hexadecimalExplained} When the \textbf{right switch} is toggled to the right, the number builder will use the hexadecimal number base.
        When the user presses a button on the \textbf{matrix keypad} then the number builder shall take the appropriate action as specified in requirement~\ref{spec:initialKeyPress} or \ref{spec:BuildingValue}.
        Buttons with decimal numerals (\textit{0-9}) or alphabetic letters (\textit{A-D}) shall be interpreted as having the corresponding hexadecimal numeral;
        the button with the octothorp (\#) shall be interpreted as having the hexadecimal numeral \textit{E};
        and the button with the asterisk (*) shall be interpreted as having the hexadecimal numeral \textit{F}.
    \item Initially, the \textbf{display module} shall be blank.
    \item \label{spec:illuminateLED} Whenever the user presses a key on the \textbf{matrix keypad}, the \textbf{right LED} (aka, the external LED) shall illuminate for approximately one-half of a second.
        Whenever the user presses one of the \textbf{pushbuttons}, the \textbf{left LED} (aka the internal LED) shall illuminate for approximately one-half of a second.
    \item \label{spec:LEDoffWhenOtherwise} The \textbf{LEDs} shall not illuminate except as specified in requirement~\ref{spec:illuminateLED}.
        %Exception: the \textbf{left LED} may blink as a consequence of its pin being used as the SPI \texttt{SCK} signal.
        There is no prohibition against the \developmentboard's \texttt{TX}, \texttt{RX}, and \texttt{PWR} LEDs illuminating.
    \item The system shall build numbers in response to user input:
        \begin{enumerate}
        \item \label{spec:32bits} The numbers' values shall be representable as 32-bit signed integers.
        \item \label{spec:initialKeyPress} If the display is blank (\textit{i.e.}, there is not yet a number being built), then whenever the user presses a button on the \textbf{matrix keypad}, the corresponding numeral shall be displayed on the \textbf{display module}'s top row, either in the far-left column or the far-right column, depending on the alignment mode.
            The numeral displayed shall follow the interpretations specified in requirements~\ref{spec:decimalExplained} and \ref{spec:hexadecimalExplained}.
        \item \label{spec:BuildingValue} If the display is not blank (\textit{i.e.}, there is a number being built), then whenever the user presses a button on the \textbf{matrix keypad}, the corresponding numeral shall become the least-significant digit of the number shown on the \textbf{display module};
            all pre-existing digits shall increase in significance by one order of magnitude.
            For example, if \display{234} is displayed and the user presses \texttt{5}, then \display{2345} shall be displayed.
            The numeral displayed shall follow the interpretations specified in requirements~\ref{spec:decimalExplained} and \ref{spec:hexadecimalExplained}.
            \begin{enumerate}
                \item There shall be no noticeable lag in updating the display.
                \item The alignment mode shall be preserved.
                    If in left justified mode, then the most-significant digit shall remain in the leftmost column.
                    If in right justified mode, then the new least-significant digit shall be in the rightmost column.
                % \item \label{spec:printValueToConsole} The new value shall be printed
                %     to the Serial Monitor in decimal or hexadecimal, depending on the
                %     system's current number base.
            \end{enumerate}
        \item ``0x'' shall be displayed as part of a hexadecimal value (``0x'' is optional when the value is 0).
        % \item ``0x'' shall not be displayed as part of a hexadecimal value.
        \item Whenever the user presses the \textbf{left pushbutton}, the value
            being displayed shall be negated.
            \begin{enumerate}
                \item In the decimal number base, the presence or absence of negative sign shall indicate whether or not a value is negative.
                \item In the hexadecimal number base, 32-bit two's complement shall be used.
            \end{enumerate}
        \item A positive sign shall not be displayed as part of a positive value.
        \item If a negative decimal value is displayed, the negative sign shall be displayed immediately to the left of the most-significant digit being displayed.
            For example, \display{-456} is correctly displayed, but \display{-\phantom{xxxx}456} is not correctly displayed.
            \begin{enumerate}
                \item If in left justified mode, the negative sign shall be in the leftmost column, and the most-significant digit shall be in the column immediately to the right of that.
            \end{enumerate}
        \item Leading 0s may be displayed but are discouraged.
            For example, \display{782} is preferred, but \display{00000782} is allowed.
        \item Digit separators are permitted but not required.
            For example, both \display{12345} and \display{12,345} are acceptable, as are both \display{0x6789A} and \display{0x6,789A}.
        \item \label{spec:clearNumber} Whenever the user presses the \textbf{right pushbutton} while a number is being built, the number that has been built shall be displayed on the bottom row, aligned according to the alignment mode, for approximately one second.
            After approximately one second, the number that has been built shall reset to 0, and the \textbf{display module} shall be cleared.
        % \item In no case shall the tool allow the user to input a value too
        %     great to be displayed on the \textbf{display module}. If
        %     the user attempts to enter a value greater than $0x7FFF,FFFF$ in
        %     hexadecimal, less than $0x8000,0000$ in hexadecimal, greater than
        %     $99,999,999$ in decimal, or less than $-9,999,999$ in decimal, then the
        %     \textbf{display module} shall display \display{too big}.
        \item \label{spec:tooBig} In no case shall the tool allow the user to input a value too great to be stored as a 32-bit signed integer.
            If the user attempts to enter a value greater than $0x7FFF,FFFF$ in hexadecimal, less than $0x8000,0000$ in hexadecimal, greater than $2,147,483,647$ in decimal, or less than $-2,147,483,648$ in decimal, then the \textbf{display module} shall display \display{too big}.
            \begin{itemize}
            \item \textit{n.b.}, in a hexadecimal 32-bit negative integer, an \texttt{F} in the most-significant hex-digit might only be a sign extension;
                in this scenario, if the user inputs another hex-digit then it is still a valid number because it would not be less than $0x8000,0000$. \\ \\
                For example, adding another digit to the 32-bit integer $0xF865,4321$ would \textit{not} produce a too-great value because the 36-bit integer $0xF,8654,3210 = -2,041,302,512_{10}$, and also the 32-bit integer $0x8654,3210 = -2,041,302,512_{10}$.
                Because $0x8000,0000 = -2,147,483,648_{10} \leq -2,041,302,512_{10}$, adding the \texttt{0} digit did not produce a ``too big'' value. \\ \\
                On the other hand, adding another digit to the 32-bit integer $0xF765,4321$ \textit{would} produce a too-great value because the 36-bit integer $0xF,7654,3210 = -2,309,737,968_{10}$, but the 32-bit integer $0x8654,3210 = 1,985,229,328_{10}$.
                Because $0x8000,0000 = -2,147,483,648_{10} > -2,309,737,968_{10}$, adding the \texttt{0} digit did produce a ``too big'' value.
            \end{itemize}
        \end{enumerate}
    \item If the user toggles the \textbf{left switch} (\textit{i.e.}, changes alignment mode):
        if no number is being displayed, then the system shall seamlessly transition between alignment modes;
        otherwise, the system's behavior is undefined.
    \item If the user toggles the \textbf{right switch} (\textit{i.e.}, changes the number base):
        if no number is displayed, or if the number 0 is displayed, then the system shall seamlessly transition between number bases;
        if a non-zero number is being built then the system's behavior is undefined.
    %\item \label{spec:singleKeypress} When the user presses a button for less than
    %    approximately one-half of a second, regardless of whether it is one of the
    %    \textbf{pushbuttons} or a key on the \textbf{matrix keypad}, it shall be treated
    %    as a single press.
    \item \label{spec:singleKeypress} When the user presses a button, regardless of whether it is one of the \textbf{pushbuttons} or a key on the \textbf{matrix keypad}, and regardless of the duration of the press, it shall be treated as a single press.
    \item \label{spec:responsive} The system shall always be responsive to user input.
        \begin{itemize}
            \item There shall be no noticeable lag in updating the display or illuminating/deluminating the LEDs.
            \item When the user is using an input device, the system shall also respond to other input devices.
                \begin{itemize}
                    \item When the user is pressing a button, the system shall respond to the user pressing the other button and/or to pressing a key on the keypad.
                    \item When the user is pressing a key, the system shall respond to the user pressing one or both of the buttons.
                    \item During the half-second that an LED is illuminated for Requirement~\ref{spec:illuminateLED}, the system shall respond to inputs (restarting the half-second if appropriate).
                \end{itemize}
            \item In general, the system shall not block except as necessary for an accurate scan of the keypad and for sending data to the display module.
        \end{itemize}
        Exceptions to Requirement~\ref{spec:responsive}:
        \begin{itemize}
            \item There is no requirement to detect that the user is simultaneously pressing multiple keys on the keypad.
            \item During the second that a number is displayed on the bottom row before the display clears (Requirement~\ref{spec:clearNumber}), if the user presses a button or key then the appropriate LED shall illuminate in accordance with Requirement~\ref{spec:illuminateLED}, but no other action is required.
        \end{itemize}
\end{enumerate}


\subsection{Using I/O Functions for Polling}

Polling, which you encountered in DuplicatorLab, is simply repeatedly checking whether some condition holds, and performing some action if it does.
In this assignment, you will poll the pushbuttons, slide-switches, and numeric keypad.
The I/O functions in \textit{io\_functions.c} access these devices to determine what buttons are pressed and what the slides' positions are.
Thus, you can poll the inputs by repeatedly calling those functions.
The specification in Section~\ref{subsec:functionalspecification} tells you what actions should be taken based on those inputs.

You may recall from the pre-lab that the Arduino toolchain provides a \lstinline{while(true)} loop that calls the \function{loop()} function on each iteration.
The \function{loop()} function in the starter code calls your \function{build_number()} function each time it's called.
This means that you can repeatedly call the I/O functions -- you can poll the inputs -- simply by calling the functions once in your \function{build_number()} function's body.

The header comments for the I/O functions in the starter code amply describe the functions.
Updating the LEDs and reading the switches' positions require no special handling;
however, polling the momentary pushbuttons and the keypad keys requires some extra care.

\subsection{Detecting Key and Button Actions}

Requirement~\ref{spec:singleKeypress} requires that each button press or key press is treated as exactly one press.
When using interrupts to detect button presses or key presses, debouncing is sufficient to ensure that only one press is detected for each actual press.
When polling the momentary pushbuttons or keypad keys, each time the \function{loop()} function executes, their position will be queried.
The problem is that the control loop iterates much faster than a human can remove their finger, and so a single press of a button or key is detected many, many times.

%You can overcome this problem by keeping track of the last time that each pushbutton was pressed and the last time that a keypress was detected.
%Then add a guard to prevent polling a pushbutton or the keypad during the half-second after the last detection.
%The code would look something like this:
%
%\begin{lstlisting}
%    if ((now - last_keypress > BUTTON_NO_REPEAT_TIME) &&
%        (...)) {
%      last_keypress = now;
%      uint8_t keypress = get_keypress();
%      ...
%    }
%\end{lstlisting}

You can overcome this problem by keeping track of the last input from a peripheral and comparing to the current input from that peripheral.
If they are the same, then either the user is still pressing that button (in which case, per Requirement~\ref{spec:singleKeypress}, there is nothing to be done), or the user is still not pressing that button (in which case there is obviously nothing to be done).
If the button previously was pressed but is now not pressed, then the user lifted their finger off the button.
If the button previously was not pressed but is now pressed, then the user \textit{just} pressed the button.

Unlike \function{test_io()}, the specification for \textit{this} system, the number builder, does not require that you detect the exact moment that a toggle switch has been moved, and so there is no need to keep track of its last position.
Indeed, the specification is written such that you don't even need to continuously poll the toggle switches' position;
however, you can do so if you find that simpler.


%\subsection{Detecting a Keypress}
%
%Detecting presses of pushbuttons and determining which button was pressed are the same action: you know whether the right or left button was pressed by whether you detected the button press with \function{left_button_is_pressed()} or \function{right_button_is_pressed()}.
%Because you don't want to unnecessarily scan the keypad, you should only call \function{get_keypress()} \textit{after} determining that a key pas been pressed.
%
%As described in Section~1.2.1 of the Cow Pi datasheet, you can determine whether or not a key was pressed by examining the input pins connected to the keypad's columns (Arduino pins D14--D17).
%If the values on all of these pins are 1, then no key is being pressed;
%on the other hand, if one of the pins has the value 0, then a key is being pressed.
%Once you have determined that a key is being pressed, you can call \function{get_keypress()}, knowing that it will return the value corresponding to one of the keys.


\subsection{Outputting to the Display Module}

You will not call \function{send_halfbyte()} directly.
Normally, instead, you would call one or more of the CowPi library's functions that work with the LCD1602 display module;
these functions, in turn, make use of \function{send_halfbyte()} after you have implemented and registered it.

This semester, however, we are experimentally providing you with a function, \function{display_string()} in \textit{supplement.h}, that handles the calls to CowPi library's LCD1602 functions.
The \function{display_string()} takes two arguments.
The first argument is a string:
the function's signature requires a string of at least 16 characters plus the terminal NUL;
we recommend that the string have \textit{exactly} 16 characters plus the terminal NUL\@.
The second argument uses an \lstinline{enum} to indicate whether the string should be displayed on the display module's top row (\lstinline{TOP_ROW}) or bottom row (\lstinline{BOTTOM_ROW}).

You are not required to use \function{display_string()}.
If you choose to directly call the CowPi library's LCD1602 functions, you will find their descriptions in Section~2.5 of the Cow Pi datasheet.
You will want to read Section~1.3 of the Cow Pi datasheet to understand the addresses used by the \function{cowpi_lcd1602_place_character()} and \function{cowpi_lcd1602_place_cursor()}.
While the datasheet's Section~1.3 also describes shifting the display, there is no part of this lab assignment that calls for shifting the display.

\subsubsection{Creating the Strings to Display Using sprintf()}

If you do not use \function{display_string()} then you are not required to create any strings, but you may.
If you do use \function{display_string()} then you obviously must create the strings that are passed to it.
The simplest way to do this is with \function{sprintf()}.

As you saw in KeyboardLab, the \function{sprintf()}\footnote{\url{https://pubs.opengroup.org/onlinepubs/7908799/xsh/fprintf.html}} is essentially a version of \function{printf()} that ``prints'' to a string.
The first argument is a pointer to the string to be printed to; the second argument is the format string (which would be \function{printf()}'s first argument), and any subsequent arguments are the variables that populate the placeholders in the format string.

The following conversion specifiers may be useful (bearing in mind that on the 8-bit microcontroller, a 32-bit value is considered to be a long integer):
\begin{description}
    \item[\%ld] Prints a decimal number
    \item[\%lx] Prints a hexadecimal number, with a--f in lowercase
    \item[\%lX] Prints a hexadecimal number, with A--F in uppercase
    \item[\%\#lx and \%\#lX] Prints a hexadecimal number, with a leading \lstinline{0x} or \lstinline{0X}.
    \item[\%nnld \%nnlx \%nnlX \%\#nnlx \%\#nnlX] ($nn$ represents some constant integer) Dedicates $nn$ spaces in the string for the number, including a minus sign or a leading \lstinline{0x}/\lstinline{0X} if present.
        The number is right-justified, and any unused space to the left is left blank.
    \item[\%0nnld \%0nnlx \%0nnlX \%\#0nnlx \%\#0nnlX] ($nn$ represents some constant integer) Dedicates $nn$ spaces in the string for the number, including a minus sign or a leading \lstinline{0x}/\lstinline{0X} if present.
        The number is right-justified, and any unused space to the left is filled with \lstinline{0}s.
    \item[\%-nnld \%-nnlx \%-nnlX \%\#-nnlx \%\#-nnlX] ($nn$ represents some constant integer) Dedicates $nn$ spaces in the string for the number, including a minus sign or a leading \lstinline{0x}/\lstinline{0X} if present.
        The number is left-justified, and any unused space to the right is left blank.
\end{description}

\subsubsection{Creating the Strings Without Using sprintf()}

Normally, using \function{printf()} and \function{sprintf()} in embedded systems is not a good idea.
One significant consideration is the impact on your program's size: \function{printf()} and \function{sprintf()} add a little over 1.5kB to the program.\footnote{
    Most of this is the code to generate the desired output/string, so eliminating only one of the functions doesn't save more than a few dozen bytes.
}
You may have noticed that only 30kB\footnote{
    The ATmega328P has 32kB of flash memory for programs, but 2kB of that is used by the bootloader.
} is available for your program in the \developmentboard's flash memory, so \function{printf()} and \function{sprintf()} take up 5.4\% of the total space available for your program!
Because of the \function{test_io()} code, your program is already includes the \function{printf()} and \function{sprintf()} functions, so you won't see any memory penalties for using them in your number builder code.

The other consideration is the time budget.
Processing a format string each time you need to update the display can be very time consuming.
It's unlikely that you'll notice any impact on the your program's responsiveness, but in an embedded system with more-stringent timing requirements, it could be an issue.

You know more about how the program uses strings than \function{printf()} and \function{sprintf()} do.
This knowledge will often allow you to generate and/or manipulate strings much, much faster.
Indeed, the number builder's specification allows for some very fast string manipulations to be used instead of \function{sprintf()} to produce the strings you can send to \function{display_string()}.

Using \function{sprintf()} will not affect your ability to earn full credit on this assignment.
However, we are offering a small bonus if your number builder implementation produces the correct output without ever calling \function{printf()}, \function{sprintf()}, \function{snprintf()}, or \function{fprintf()}.


\subsection{Measuring the Passage of Time}

Requirement~\ref{spec:illuminateLED} requires that LEDs be illuminated for 500ms after button presses or key presses.
Requirement~\ref{spec:clearNumber} requires that the number be displayed on the bottom row for 1000ms before the display is completely cleared.
You cannot use the Arduino \function{delay()} function because that would violate one of this assignment's constraints.
The \function{delay()} function and other blocking solutions are also contrary to Requirement~\ref{spec:responsive}.
You can, however, use the Arduino \function{millis()} function to determine how long, in milliseconds, your program has been running and implement a non-blocking solution to these requirements.

\ifbool{offerdecompositionhints}{
    In the case of Requirement~\ref{spec:illuminateLED}, you can call \function{millis()} in each execution of \function{build_number()} to determine the system time.
    Using that ``now'' value, you can keep track of when an LED was required to illuminate.
    If you compare the current time to the time that an LED was required to illuminate, you know whether an LED should be illuminated or not.\footnote{
        \textit{Technically}, this will also cause the LED to illuminate after 7 weeks of inactivity, violating Requirement~\ref{spec:LEDoffWhenOtherwise}, but we promise not to test for that particular scenario.
    }
    You do not even need to check whether the LED is already illuminated:
    calling \lstinline{set_xx_led(true)} will illuminate that LED if it is not illuminated and will leave it illuminated if it already is.
    Similarly, calling \lstinline{set_xx_led(false)} will deluminate that LED if it is illuminated and will leave it deluminated if it is already off.

    The idea is similar for Requirement~\ref{spec:clearNumber}.
}{}


\ifbool{offerdecompositionhints}{
    \subsection{Building 32-Bit Numbers}

    \subsubsection{Building Numbers}

    Some students in the past had difficulty implementing Requirement~\ref{spec:BuildingValue}.

    Let us consider the case where you're building a decimal number.
    Viewed as a weighted sum, an $n$-digit number $d_{n-1}d_{n-2}{\dots}d_2d_1d_0$ has the value
    \[\sum_{i=0}^{n-1}d_i \times 10^i\]

    Requirement~\ref{spec:BuildingValue} states than when you introduce a new digit, $d_{new}$, it will be the least-significant digit (that is, its weight will be ``times 1''), and all pre-existing digits will increase in significance by one order of magnitude.
    So the new value is
    \[\left(\sum_{i=0}^{n-1}d_i \times 10^{i+1}\right) + d_{new} \times 1
    = \left(\sum_{i=0}^{n-1}d_i \times 10^i \times 10\right) + d_{new}
    = \left(10 \times \sum_{i=0}^{n-1}d_i \times 10^i\right) + d_{new}\]

    So, if you're building a positive decimal number, you update the number by multiplying the old value by 10 and adding the new digit.

    The idea is similar when you're building a negative number.
    The idea is similar when you're building a hexadecimal number.

    \subsubsection{Too-Big Numbers}

    Requirement~\ref{spec:tooBig} is really about signed integer overflow.
    Requirement~\ref{spec:32bits} says that the number has to be representable as a 32 bits signed integer;
    if the number cannot fit in 32 bits then it is too big.

    You can determine that ``too big'' should be displayed either by predicting that overflow \textit{will} happen, or by determining that overflow \textit{has} happened.

    \paragraph{Detecting that Overflow Has Happened}

    Because multiplication is involved, detecting overflow after-the-fact isn't as simple as checking ``if the result is less than in operands\dots''
    The surest way is to use more bits.
    Using 64-bit arithmetic on an 8-bit microcontroller doesn't sound particularly appealing for our time budget and memory budget, but it is tremendously simple.
    You can cast the 32-bit value to \lstinline{int64_t}, perform the arithmetic, cast it back to \lstinline{int32_t} or \lstinline{long}\footnote{
        Remember: on an 8-bit processor, a \lstinline{long} only has 32 bits.
    } and see if the value is different than the 64-bit value.

    If the combination of \function{sprintf()} and 64-bit arithmetic introduces no noticeable lag, then this is fine.

    \paragraph{Predicting that Overflow Will Happen}

    Except for a couple of edge cases, predicting overflow isn't too challenging and will avoid all of the messy casting mentioned above.

    \textit{Hexadecimal}: What is in bits~31..28 (the most-significant half-byte) of the ``old value'' (before updating it with the new digit)?
    If it's anything other than \lstinline{0x0} or \lstinline{0xF}, overflow will happen.
    If it's \lstinline{0xF} then overflow may happen, depending on the value of bit~27.

    \textit{Decimal}: If you know what $\frac{1}{10}$ of \lstinline{INT32_MAX} and $\frac{1}{10}$ of \lstinline{INT32_MIN} (found in \lstinline{<limits.h>}) are, then you can compare the ``old value'' to those, to determine if multiplying by 10 will overflow.
    If multiplication won't overflow, then multiply the old value by 10 and compare that product with \lstinline{INT32_MAX} and \lstinline{INT32_MIN} to determine if the difference is less than the value of the new digit.

    \textit{Negation}: Normally, negation doesn't overflow.
    But what happens when you negate \lstinline{INT32_MIN}?

}{}
