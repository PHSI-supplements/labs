%%
%% PollingLab (c) 2021-22 Christopher A. Bohn
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%     http://www.apache.org/licenses/LICENSE-2.0
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%

\input{../../common/assignment.tex}
\input{../../common/semester.tex}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{addfont}
\addfont{OT1}{d7seg}{\dviiseg}
% \addfont{OT1}{deseg}{\deseg}
\usepackage{subfig}
% \usepackage{wrapfig}
\usepackage{multicol}
% \usepackage{caption}
% \captionsetup{width=.8\linewidth}

% \lstset{language=c, numbers=left, showstringspaces=false,
%     moredelim = [s][\ttfamily]{/*}{*/} % I shouldn't need this parameter!
%     }



\renewcommand{\labnumber}{\pollinglabnumber}
\renewcommand{\labname}{Using Polling with Memory-Mapped Input/Output}
\renewcommand{\shortlabname}{memory-mapped i/o -- pollinglab}
\renewcommand{\collaborationrules}{\pollinglabcollaboration}
\renewcommand{\duedate}{\pollinglabdue}
\newcommand{\nano}{\developmentboard} % TODO: replace \nano with \developmentboard
\renewcommand{\runtimeenvironment}{\pollinglabenvironment}
\pagelayout
\begin{document}
\labidentifier

In this assignment, you will write functions to use the input and output
devices on \runtimeenvironment. You will then use those functions to implement
the ability to build a number, similar to entering a value on a calculator,
using polling.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{AreWeThereYet}
    \caption{Polling. \tiny Image by 20th Century Fox Television}
\end{figure}

The instructions are written assuming you will edit the code in the Arduino IDE
and run it on \runtimeenvironment, constructed according to the pre-lab
instructions. If you wish, you may edit the code in a different environment;
however, our ability to provide support for problems with other IDEs is limited.

\section*{Learning Objectives}

After successful completion of this assignment, students will be able to:
\begin{itemize}
\item Use memory-mapped I/O to obtain inputs from peripheral devices
\item Use memory-mapped I/O to send outputs to peripheral devices
\item Poll an input to determine when it has taken on a value of interest
\item Scan a matrix keypad
% \item Use the Serial-Parallel Interface (SPI) protocol
\item Use the Inter-Integrated Circuit (I$^2$C) protocol
% \item Display a value or a message on a collection of 7-segment displays
\item Display a value or a message on a dot-matrix character display
\end{itemize}

\subsection*{Continuing Forward}

We will use the hardware kit for the remaining labs. In the labs after this one,
you will not be required to use the memory-mapped I/O registers (but you may!);
however, we will assume that you know how to scan a matrix keypad, and that you
can build and display a value from keypad inputs.

\section*{During Lab Time}

During your lab period, the TAs will provide a refresher on bitmasks, both to
read inputs and to use the read-modify-write pattern for outputs. They will also
discuss some subtle semantics problems that students have encountered in the
past. Finally, the TAs will guide the class through the first modification to
the starter code that you must make. During the remaining time, the TAs will be
available to answer questions.

\softwareengineeringfrontmatter

\section{Scenario}

Archie walks up to you, along with Herb Bee from Eclectic Electronics. Herb is
holding a tangled mess of electronics. Archie explains, ``Herb here has
developed a prototype of a device that he thinks will be useful for our
physical security needs, as well as a few other applications around here. He
calls it the \textit{Cow Pi}.''

You look at the device in Herb's hands and see the \nano\ central to the circuit. ``Isn't \textit{-Pi} typically used as a suffix for circuits that use a Raspberry Pi instead of an Arduino?''

Herb replies, ``Typically, yes, but \textit{Cowduino} isn't very punny, is it?''

Archie chimes in, ``Maybe with the right emphasis: \textit{Cow-DOO-ino}.''

``That's kind of subtle, don't you think? How will people know to put the
emPHAsis on that sylLAble?''

``I think we're getting off topic here,'' you point out. ``How can I help?''

``Oh, right,'' Herb says, ``We'd like you to kick its proverbial tires. Let's
start off with something simple, like a number builder tool.''


\section{Lab Overview}

Please familiarize yourself with the entire assignment before beginning.
Your first action must be to populate the keypad's lookup table (Section~\ref{sec:populateKeypad}).
Next you must introduce debouncing code to the I/O functions in the starter code (Section~\ref{sec:debouncing}).
After that, there are two major parts to this assignment, and they can be completed in either order.

\subsection{Memory-Mapped Input/Output}

The starter code contains functions that provide access to the buttons, switches, keypad, LEDs, and display module.
Initially, these functions make use of functions available in the CowPi library.
In Section~\ref{sec:MemMapIO}, you will re-implement these functions using memory-mapped I/O.

\subsection{Implementing a Simple System using Polling}

In Section~\ref{sec:SimpleSystem}, you will implement a simple system that makes use of your hardware kit's buttons, switches, keypad, LEDs, and display module.
You will implemnent this system by polling inputs.

% Please familiarize yourself with the entire assignment before beginning.
% Section~\ref{sec:FunctionalSpecification} has the functional specification of
% the system you will develop. Section~\ref{sec:Constraints} describes
% implementation constraints. Section~\ref{sec:DemonstrationMode} guides you in
% implementing the first portion of the system, and
% Section~\ref{sec:BuildingMode} offers suggestions in implementing the second
% portion of the system.

\subsection{Constraints} \label{sec:Constraints}

You may use any features that are part of the C standard if they are supported by the compiler. You may use the constants and functions provided in the starter code (to receive credit for the memory-mapped I/O portion of this lab, you will need to re-implement the I/O functions).

You must detect inputs using polling; you may not use interrupts.

All of your code must go in \textit{number\_builder.ino}.

\subsubsection{Constraints on the Arduino core}

You may use the \function{millis()} function to implement debouncing.
You may use the \function{delayMicroseconds()} function to introduce a 1$\mu$s delay in \function{get_keypress()} and to introduce a 1$\mu$s delay in \function{send_halfbyte()}.
You may (but are not required to) use \function{Serial.print()} and \function{Serial.println()} instead of \function{printf()} if you wish.

You may not use any other libraries, functions, macros, types, or constants from the Arduino core.\footnote{\url{https://www.arduino.cc/reference/en/}}

\subsubsection{Constraints on AVR-libc}

You may not use any AVR-specific functions, macros, types, or constants of avr-libc.\footnote{\url{https://www.nongnu.org/avr-libc/user-manual/index.html}}

\subsubsection{Constraints on the CowPi library}

To receive credit for the memory-mapped I/O portion of this lab, all input and
output must be accomplished using the memory-mapped I/O registers.
You may not use the functions described in Sections~2.2--2.4 of the Cow Pi datasheet.

You may use any functions that that send characters or commands to the display module that are described in Section~2.5 of the Cow Pi datasheet.
Your \function{send_halfbyte()} function, however, must be implemented using memory-mapped I/O registers.

\subsubsection{Constraints on other libraries}

You may not use any libraries beyond those explicitly identified here.



\section{Populate the Keypad's Lookup Table} \label{sec:populateKeypad}

Locate the \lstinline{keys} $4 \times 4$ nested array on lines 72--77 of \textit{number\_builder.ino}.
This nested array serves as a lookup table to obtain the appropriate value when a key is pressed.
\textit{Even the starter code depends on this nested array being populated correctly.}
The element \lstinline{keys[0][0]} will correspond to the \texttt{1} key;
\lstinline{keys[0][3]} will correspond to the \texttt{A} key;
\lstinline{keys[3][0]} will correspond to the \texttt{*} key;
and \lstinline{keys[3][3]} will correspond to the \texttt{D} key.

We want the numerals \texttt{0}-\texttt{9} to produce their respective decimal
(and hexadecimal) values. We want \texttt{A}-\texttt{D} to produce their
respective hexadecimal values. We want \texttt{\#} to produce the hexadecimal
value 0xE, and we want \texttt{*} to produce the hexadecimal value 0xF.

\begin{itemize}
    \item Populate \lstinline{keys}' nested array initializer so that the
        lookup table will produce the correct value for each row/column
        combination.
\end{itemize}

You can confirm that you correctly populated the array's initializer by running the test code.
Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}:

\begin{lstlisting}
void loop() {
  test_io();
  // build_number();
}
\end{lstlisting}

Upload the program to your \developmentboard.
The test code will output on both the Serial Monitor and on the display module.
The output will include the key that was pressed (if any), a hyphen if no key is being pressed, or a question mark if \function{get_keypress()} returns an invalid value.

\begin{lstlisting}
    ...
    char key_character;
    if (key_pressed <= 9) {
      key_character = key_pressed + '0';
    } else if (0xA <= key_pressed && key_pressed <= 0xF) {
      key_character = key_pressed - 0xA + 'A';
    } else if (key_pressed == 0xFF) {
      key_character = '-';
    } else {
      key_character = '?';
    }
    ...
\end{lstlisting}

Familiarize yourself with the test code's other outputs.
The output will include the positions of the left and right buttons (``U'' for up and ``D'' for down) and of the left and right switches (``L'' for left position and ``R'' for right position).

\begin{lstlisting}
    ...
    left_button_position ? 'D' : 'U', right_button_position ? 'D' : 'U',
    left_switch_position ? 'R' : 'L', right_switch_position ? 'R' : 'L'
    ...
\end{lstlisting}

Finally, if both buttons are pressed then the left LED will illuminate, and if both switches are in the right position then the right LED will illuminate.

\begin{lstlisting}
    ...
    set_left_led(left_button_position && right_button_position);
    set_right_led(left_switch_position && right_switch_position);
    ...
\end{lstlisting}



\section{Debouncing} \label{sec:debouncing}

Mechanical buttons and switches demonstrate a phenomenon called \textit{switch bounce}.
This causes voltage to fluctuate for hundreds of microseconds when the contacts close or open.
When this fluctuation is in the indeterminate region between the logical low and high thresholds, it can cause the logic level to ``bounce'' back-and-forth between high and low until settling into the final, correct logic level.
This causes the digital circuitry or software to ``see'' multiple triggering events.

A traditional way to debounce is to introduce a simple low-pass filter using a resistor and a capacitor.
Other common hardware-based approaches use digital feedbck circuits.

Hardware design can be simplified by solving a hardware problem with software, and so you will often see hobby projects with ``debouncing code'' such as \lstinline{delay(20);} that pauses execution between detecting the first change of the button's or switch's position and acting upon it for 20ms, ample time for switch bounce to stabilize. The problem (beyond \function{delay()} being disallowed in this lab) is that 20ms is a long time to leave your system completely non-responsive.

The solution you will use allows your system to continue to respond to other external events. For example, you can press both buttons at very nearly the same time (or, unlikely, at the exact same time) and the software will react to both immediately.

Briefly examine the starter code's implementation of \function{get_keypress()}.
Notice that there are two \lstinline{static} variables,\footnote{
A function-local variable modified with the \lstinline{static} keyword is allocated on the heap but remains scope-limited to that function.
Its initializer runs only once, and then its value is preserved between calls to that function.}
one to remember the last time that a true keypress was detected, and one to remember the last value read from the keypad.
If fewer than 20ms have passed since the last true keypress, then the keypress that was detected is due to switch bounce, and so the function simply returns the last value read from the keypad.
If more than 20ms have passed, then we know that this is a new keypress, and so both of these variables are updated.

\section{Memory-Mapped Input/Output} \label{sec:MemMapIO}

In this section, you will use the data structures provided by the CowPi library to access the \developmentboard's memory-mapped I/O registers.
You will use the same test code from Section~\ref{sec:populateKeypad} to test your code.

If you have already implemented the system from Section~\ref{sec:SimpleSystem}, you may want to make a backup copy of your program now.

Make sure that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.

\subsection{Simple Inputs and Outputs}

You will use an array of \lstinline{cowpi_ioport_t} structures to access the memory-mapped I/O registers for the \developmentboard's external pins.

Read Section~4.1 of the Cow Pi datasheet.
After you have done so,
\begin{itemize}
    \item Uncomment the first line of the starter code's \function{initialize_io()} function, and
    \item Assign the appropriate address to the \lstinline{ioports} pointer on that line.
\end{itemize}

\begin{lstlisting}
void initialize_io(void) {
  // ioports = (cowpi_ioport_t *)(cowpi_io_base + 0);
  // i2c = (cowpi_i2c_t *)(cowpi_io_base + 0);
  // cowpi_lcd1602_set_send_halfbyte_function(send_halfbyte);
}
\end{lstlisting}

You can now use the \lstinline{ioports} pointer as an array of \lstinline{cowpi_ioport_t} structures, which you can index using the \lstinline{D0_D7}, \lstinline{D8_D13}, and \lstinline{D14_D19} named constants.

\subsubsection{Simple Inputs}

Locate the \function{left_button_is_pressed()}, \function{right_button_is_pressed()}, \\ \function{left_switch_in_left_position}, \function{left_switch_in_right_position()}, \\ \function{right_switch_in_left_position()}, and  \function{right_switch_in_right_position()} functions.
In the starter code, these functions are implemented by calling functions in the CowPi library, and they are not debounced.\footnote{
The test code has debouncing code, but a better design would have debouncing code in the functions that report the controls' positions.}

\begin{itemize}
    \item Modify these six functions to have debouncing code, and
    \item Replace the calls to CowPi library functions with code that uses the \lstinline{ioports} array to ascertain the controls' positions.
\end{itemize}

Make sure that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
The output will include the positions of the left and right buttons (``U'' for up and ``D'' for down) and of the left and right switches (``L'' for left position and ``R'' for right position).

\subsubsection{Simple Outputs}

Locate the \function{set_left_led()} and \function{set_right_led()} functions.
In the starter code, these functions are implemented by calling functions in the CowPi library.

\begin{itemize}
    \item Modify these two functions to replace the calls to CowPi library functions with code that uses the \lstinline{ioports} array to turn the LEDs on or off.
\end{itemize}

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
If both buttons are pressed then the left LED will illuminate, and if both switches are in the right position then the right LED will illuminate.

\subsection{Scanned Input}

Locate the \function{get_keypress()} function.
Not including the debouncing code, the implementation in the starter code calls the CowPi library's \function{cowpi_get_keypress()} function.
The \function{cowpi_get_keypress()} function returns a \lstinline{char} corresponding to the character on the pressed key,
but the \function{get_keypress()} function is supposed to return a \lstinline{uint8_t} that has the hexadecimal value of the pressed key (considering \# as 0xE and * as 0xF).
Because of this, the rest of the implementation is a \lstinline{swtich} statement to obtain the correct value from the \function{keys} nested array.

Read Section~1.2 of the Cow Pi datasheet.
After you have done so:

\begin{itemize}
    \item Preserve the debouncing code in \function{get_keypress()}, and
    \item Replace the starter code's call to \function{cowpi_get_keypress()} and \lstinline{switch} statement with code that scans the keyboard.
        \begin{itemize}
            \item Use the \lstinline{ioports} array to read from and write to the appropriate pins,
            \item Use \lstinline{delayMicroseconds(1)} for the delay shown on line 4 of the pseudocode in Section~1.2.2 of the datasheet, and
            \item Use the \lstinline{keys} nested array to obtain the correct integer value for the key at a given row and column.
        \end{itemize}
\end{itemize}

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
The output will include the key that was pressed (if any), a hyphen if no key is being pressed, or a question mark if \function{get_keypress()} returns an invalid value.


\subsection{Display Module}

You will use a pointer to a \lstinline{cowpi_i2c_t} structure to access the memory-mapped I/O registers for the \developmentboard's I$^2$C (aks ``TWI'') hardware,
and you will use those registers to send data to the display module.

Read Section~1.3 of the Cow Pi datasheet to familiarize yourself with the physical characteristics of the display module.
Read the datasheet's Section~4.2 to familiarize youself with the I$^2$C registers (Sections~4.2.1--4.2.2), with the I$^2$C handshake and transmission sequence (Section~4.2.3), and with the data format and the steps required by the display module itself (Section~4.2.4). After you have done so:

\begin{itemize}
    \item Uncomment the second line of the starter code's \function{initialize_io()} function, and
    \item Assign the appropriate address to the \lstinline{i2c} pointer on that line.
\end{itemize}

You can now use the \lstinline{i2c} pointer to operate the I$^2$C hardware.
Now locate the \function{send_halfbyte()} function.

\begin{itemize}
    \item Implement the pseudocode from the datasheet's Section~4.2.3, to
    \item Send the three bytes of data described in the datasheet's Section~4.2.4.
        \begin{itemize}
            % \item You may handle the error conditions show in the pseudocode in whatever manner you see fit; it would be best to do so in a manner that allows you to determine \textit{which} error is occurring.
            \item Use \lstinline{delayMicroseconds(1)} to implement the pulse described in Section~4.2.4 of the datasheet.
        \end{itemize}
\end{itemize}

After you are satisfied that you have implemented the \function{send_halfbyte()} function correctly:

\begin{itemize}
    \item Uncomment the third line of the starter code's \function{initialize_io()} function to register \function{send_halfbyte()} with the CowPi library's LCD1602 code.
\end{itemize}

All of the functions in the CowPi library that send characters or commands to the display module will now make use of your \function{send_halfbyte()} function.

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
If the test code displays its outputs on the display module, then you implemented \function{send_halfbyte()} correctly. If the test code displays its outputs on the Serial Monitor but not the display module, or if the test code does not run at all, then there is an error in your code.



\section {Implementing a Simple System Using Polling} \label{sec:SimpleSystem}

In this section you will implement a ``number builing tool'' that turns a sequence of inputs into a number.
A notional use of this number builder would be to create the operands for a calculator.
Section~\ref{sec:FunctionalSpecification} has the tool's specification.
You should design your system using the I/O functions -- either the implementations from the starter code with the debouncing code added, or the implementations you wrote (or will write) from Section~\ref{sec:MemMapIO}.
After the specification are a few suggestions for making good use of those functions.

If you have already implemented the I/O code from Section~\ref{sec:MemMapIO}, you may want to make a backup copy of your program now.

Make sure that \textit{number\_builder.ino}'s \function{loop()} function calls \function{build_number()} and not \function{test_io()}.


\subsection{Number Builder Specification} \label{sec:FunctionalSpecification}

\begin{enumerate}
\item The tool shall have two alignment modes, \textit{left justified mode} and
    \textit{right justified mode}. The \textbf{left switch} controls the alignment mode.
    When the \textbf{left switch} is toggled to the left, the tool shall be in left justified mode.
    When the \textbf{left switch} is toggled to the right, the tool shall be in right justified mode.
\item The tool shall have two number bases, \textit{decimal} and
    \textit{hexadecimal}. The \textbf{right switch} controls the number base.
\item \label{spec:decimalExplained} When the \textbf{right switch} is toggled
    to the left, the number builder will use the decimal number base. When the
    user presses a button on the \textbf{matrix keypad} with a decimal numeral
    (\textit{0-9}) then the number builder shall take the appropriate action as
    specified in requirement \ref{spec:initialKeyPress} or
    \ref{spec:BuildingValue}. Any other buttons on the keypad shall be ignored.
\item \label{spec:hexadecimalExplained} When the \textbf{right switch} is
    toggled to the right, the number builder will use the hexadecimal number
    base. When the user presses a button on the \textbf{matrix keypad} then the
    number builder shall take the appropriate action as specified in
    requirement \ref{spec:initialKeyPress} or \ref{spec:BuildingValue}.
    Buttons with decimal numerals (\textit{0-9}) or alphabetic letters
    (\textit{A-D}) shall be interpreted as having the corresponding hexadecimal
    numeral; the button with the octothorp (\#) shall be interpreted as having
    the hexadecimal numeral \textit{E}; and the button with the asterisk (*)
    shall be interpreted as having the hexadecimal numeral \textit{F}.
\item Initially, the \textbf{display module} shall be blank.
\item \label{spec:illuminateLED} Whenever the user presses a key on the
    \textbf{matrix keypad}, the \textbf{right LED} (aka, the external LED) shall
    illuminate for approximately one-half of a second. Whenever the user presses
    one of the \textbf{pushbuttons}, the \textbf{left LED} (aka the internal LED)
    shall illuminate for approximately one-half of a second.
\item The \textbf{LEDs} shall not illuminate except as specified in
    requirement~\ref{spec:illuminateLED}.
    %Exception: the \textbf{left LED} may blink as a consequence of its pin being used as the SPI \texttt{SCK} signal.
    There is no prohibition against the \developmentboard's \texttt{TX},
    \texttt{RX}, and \texttt{PWR} LEDs illuminating.
\item The system shall build numbers in response to user input:
    \begin{enumerate}
    \item The numbers' values shall be representable as 32-bit signed integers.
    \item \label{spec:initialKeyPress} If the display is blank
        (\textit{i.e.}, there is not yet a number being built), then whenever the
        user presses a button on the \textbf{matrix keypad}, the corresponding
        numeral shall be displayed on the \textbf{display module}'s top row,
        either in the far-left column or the far-right column, depending on the
        alignment mode. The numeral displayed shall follow the interpretations
        specified in requirements \ref{spec:decimalExplained} and
        \ref{spec:hexadecimalExplained}.
    \item \label{spec:BuildingValue} If the display is not blank (\textit{i.e.},
        there is a number being built), then whenever the user presses a button
        on the \textbf{matrix keypad}, the corresponding numeral shall become
        the least-significant digit of the number shown on the
        \textbf{display module}; all pre-existing digits shall increase in
        significance by one order of magnitude. For example, if \display{234} is
        displayed and the user presses \texttt{5}, then \display{2345} shall be
        displayed. The numeral displayed shall follow the interpretations
        specified in requirements \ref{spec:decimalExplained} and
        \ref{spec:hexadecimalExplained}.
        \begin{enumerate}
        \item There shall be no noticeable lag in updating the display.
        \item The alignment mode shall be preserved. If in left justified mode,
            then the most-significant digit shall remain in the leftmost column.
            If in right justified mode, then the new least-significant digit
            shall be in the rightmost column.
        % \item \label{spec:printValueToConsole} The new value shall be printed
        %     to the Serial Monitor in decimal or hexadecimal, depending on the
        %     system's current number base.
        \end{enumerate}
    \item ``0x'' shall be displayed as part of a hexadecimal value.
    % \item ``0x'' shall not be displayed as part of a hexadecimal value.
    \item Whenever the user presses the \textbf{left pushbutton}, the value
        being displayed shall be negated.
        \begin{enumerate}
        \item In the decimal number base, the presence or absence of negative
            sign shall indicate whether or not a value is negative.
        \item In the hexadecimal number base, 32-bit two's complement shall be
            used.
        \end{enumerate}
    \item A positive sign shall not be displayed as part of a positive value.
    \item If a negative decimal value is displayed, the negative sign shall
        be displayed immediately to the left of the most-significant digit
        being displayed. For example, \display{-456} is correctly
        displayed, but \display{-\phantom{xxxx}456} is not correctly displayed.
        \begin{enumerate}
        \item If in left justified mode, the negative sign shall be in the
            leftmost column, and the most-significant digit shall be in the
            column immediately to the right of that.
        \end{enumerate}
    \item Leading 0s may be displayed but are discouraged. For example,
        \display{782} is preferred, but \display{00000782} is allowed.
    \item Digit separators are permitted but not required. For example, both
        \display{12345} and \display{12,345} are acceptable, as are both
        \display{0x6789A} and \display{0x6,789A}.
    \item Whenever the user presses the \textbf{right pushbutton} while a number
        is being built, the number that has been built shall be displayed on the
        bottom row, aligned according to the alignment mode, for approximately
        one second. After approximately one second, the number that has been
        built shall reset to 0, and the \textbf{display module} shall be cleared.
        % \item In no case shall the tool allow the user to input a value too
        %     great to be displayed on the \textbf{display module}. If
        %     the user attempts to enter a value greater than $0x7FFF,FFFF$ in
        %     hexadecimal, less than $0x8000,0000$ in hexadecimal, greater than
        %     $99,999,999$ in decimal, or less than $-9,999,999$ in decimal, then the
        %     \textbf{display module} shall display \display{too big}.
        \item In no case shall the tool allow the user to input a value too
            great to be stored as a 32-bit signed integer. If the user attempts to
            enter a value greater than $0x7FFF,FFFF$ in hexadecimal, less than
            $0x8000,0000$ in hexadecimal, greater than $2,147,483,647$ in decimal, or
            less than $-2,147,483,648$ in decimal, then the \textbf{display module}
            shall display \display{too big}.
            \begin{itemize}
            \item \textit{n.b.}, in a hexadecimal 32-bit negative integer, an
                \texttt{F} in the most-significant hex-digit might only be a sign
                extension; in this scenario, if the user inputs another hex-digit
                then it is still a valid number because it would not be less than
                $0x8000,0000$. \\ \\
                For example, adding another digit to the 32-bit integer
                $0xF865,4321$ would \textit{not} produce a too-great value because
                the 36-bit integer $0xF,8654,3210 = -2,041,302,512_{10}$, and the
                32-bit integer $0x8654,3210 = -2,041,302,512_{10}$. Because
                $0x8000,0000 = -2,147,483,648_{10} \leq -2,041,302,512_{10}$, adding
                the \texttt{0} digit did not produce a ``too big'' value. \\ \\
                On the other hand, adding another digit to the 32-bit integer
                $0xF765,4321$ \textit{would} produce a too-great value because the
                36-bit integer $0xF,7654,3210 = -2,309,737,968_{10}$, but the 32-bit
                integer $0x8654,3210 = 1,985,229,328_{10}$. Because
                $0x8000,0000 = -2,147,483,648_{10} > -2,309,737,968_{10}$, adding
                the \texttt{0} digit did produce a ``too big'' value.
            \end{itemize}
    \end{enumerate}
\item If the user toggles the \textbf{left switch} (\textit{i.e.}, changes
    alignment mode): if no number is being displayed, then the system shall
    seamlessly transition between alignment modes; otherwise, the system's
    behavior is undefined.
\item If the user toggles the \textbf{right switch} (\textit{i.e.}, changes
    the number base): if no number is displayed, or if the number 0 is displayed,
    then the system shall seamlessly transition between number bases; if a
    non-zero number is being built then the system's behavior is undefined.
\item \label{spec:singleKeypress} When the user presses a button for less than
    approximately one-half of a second, regardless of whether it is one of the
    \textbf{pushbuttons} or a key on the \textbf{matrix keypad}, it shall be treated
    as a single press.
\end{enumerate}


\subsection{Using I/O Functions}

The header comments for the I/O functions in the starter code amply describe the functions.
Updating the LEDs and reading the switches' positions require no special handling;
however, polling the momentary pushbuttons and the keypad keys requires some extra care.

\subsection{Implementing Requirement~\ref{spec:singleKeypress}}

When using interrupts to detect button presses or key presses, debouncing is sufficient to ensure that only one press is detected for each actual press.
When polling the momentary pushbuttons or keypad keys, each time the \function{loop()} function executes, their position will be queried.
The problem is that the control loop iterates much faster than a human can remove their finger, and so a single press of a button or key is detected many, many times.

You can overcome this problem by keeping track of the last time that each pushbutton was pressed and the last time that a keypress was detected.
Then add a guard to prevent polling a pushbutton or the keypad during the half-second after the last detection.
The code would look something like this:

\begin{lstlisting}
    if ((now - last_keypress > BUTTON_NO_REPEAT_TIME) &&
        (...)) {
      uint8_t keypress = get_keypress();
      ...
    }
\end{lstlisting}


\subsection{Detecting a Keypress}

Detecting presses of pushbuttons and determining which button was pressed are the same action: you know whether the right or left button was pressed by whether you detected the button press with \function{left_button_is_pressed()} or \function{right_button_is_pressed()}.
Because you don't want to unnecessarily scan the keypad, you should only call \function{get_keypress()} \textit{after} determining that a key pas been pressed.

As described in Section~1.2.1 of the Cow Pi datasheet, you can determine whether or not a key was pressed by examining the input pins connected to the keypad's columns (Adruino pins D14--D17).
If the values on all of these pins are 1, then no key is being pressed;
on the other hand, if one of the pins has the value 0, then a key is being pressed.
Once you have determined that a key is being pressed, you can call \function{get_keypress()}, knowing that it will return the value corresponding to one of the keys.


\subsection{Outputting to the Display Module}

You will not call \function{send_halfbyte()} directly.
Instead, you will call one or more of the CowPi library's functions that work with the LCD1602 display module; these functions, in turn, will make use of \function{send_halfbyte()} after you have implemented and registered it.
The functions are described in Section~2.5 of the Cow Pi datasheet.

You will want to read Section~1.3 of the Cow Pi datasheet to understand the addresses used by the \function{cowpi_lcd1602_place_character()} and \function{cowpi_lcd1602_place_cursor()}.
While the datasheet's Section~1.3 also describes shifting the display, there is no part of this lab assignment that calls for shifting the display.



\section*{Turn-in and Grading}

When you have completed this assignment, upload \textit{PollingLab.ino} to
\filesubmission.

This assignment is worth 40 points. \\

Rubric:
\begin{description}
\rubricitem{1}{The inputs are debounced in software in a fashion that permits other inputs to be handled as they arrive.}
\item[Memory-Mapped Input/Output]
\rubricitem{6}{The simple input/output functions are correctly implemented. (2 points for \function{xx_switch_in_xx_position()} functions; 2 points for \function{xx_button_is_pressed()} functions; 2 points for \function{set_xx_led()} funcitons)}
\rubricitem{8}{The \function{get_keypress()} function is correctly implemented.}
\rubricitem{8}{The \function{send_halfbyte()} function is correctly implemented.}
\item[Implementing a Simple System using Polling]
\rubricitem{2}{Left justified mode and right justified mode are implemented correctly.}
\rubricitem{2}{Decimal and hexadecimal number bases are implemented correctly.}
\rubricitem{2}{The LED illumination occurs as specified.}
\rubricitem{2}{The first digit of a number is displayed in the correct position, making a blank display no longer blank, in accordance with requirements~\ref{spec:decimalExplained}, \ref{spec:hexadecimalExplained}, and \ref{spec:initialKeyPress}.}
\rubricitem{2}{Subsequent digits update the number in accordance with requirements~\ref{spec:decimalExplained}, \ref{spec:hexadecimalExplained}, and \ref{spec:BuildingValue}.}
\rubricitem{2}{The left pushbutton negates the number's value (\textonehalf\ point for each of: negating positive decimal values, negating negative decimal values, negating positive hexadecimal values, negating negative hexadecimal values)}
\rubricitem{2}{Detects and displays correct message when the number being built is too big. (\textonequarter\ point for detecting too-big numbers for each of: positive decimal numbers, negative decimal numbers, positive hexadecimal numbers, negative hexadecimal numbers; \textonequarter\ point for no false detections among each of: decimal numbers, hexadecimal numbers; \textonehalf\ point for printing the correct message)}
\rubricitem{2}{The right pushbutton causes a copy of the number to be displayed on the bottom row for one second, after which the display clears.}
\rubricitem{1}{A button press or a key press that lasts fewer than 500ms is treated as a single press.}
\bonusitem{2}{Get assignment checked-off by TA or professor during office hours before it is due. (You cannot get both bonuses.)}
\bonusitem{1}{Get assignment checked-off by TA at \textit{start} of your scheduled lab immediately after it is due. (Your code must be uploaded to \filesubmission\ \textit{before} it is due. You cannot get both bonuses.)}
\item[Penalties]
\penaltyitem{22}{The memory-mapped input/output functions' implementations violate one or more constraints identified in Section~\ref{sec:Constraints}.}
\penaltyitem{17}{The simple system's implementation violates one or more constraints identified in Section~\ref{sec:Constraints}.}
\spaghetticodepenalties{1}
\end{description}

\section*{Epilogue}

Herb looks over your work. ``Hmm, yes. I think this is coming along nicely.
Let's run a few more tests.''

Archie storms into the room. ``We have \textit{got} to do something about
security! How's that doodad coming along? Because there's now a
 half-man/half-fly in the labs going on-and-on about Chaos Theory and how if we
 just give him a MacBook and a spaceship then he'll be able to get the Lord of
 Thunder to travel across the 8th Dimension. Is that thing just about ready?''

Herb shakes his head, ``No, not quite yet. It should be ready in about a week.''

\textit{To be continued...}

\newpage

\section*{Appendix: Lab Checkoff}

You are not required to have your assignment checked-off by a TA or the
professor. If you do not do so, then we will perform a functional check
ourselves. In the interest of making grading go faster, we are offering a small
bonus to get your assignment checked-off at the start of your scheduled lab
time immediately after it is due. Because checking off all students during lab
would take up most of the lab time, we are offering a slightly larger bonus if
you complete your assignment early and get it checked-off by a TA or the
professor during office hours.

\begin{enumerate}
\precheckoffitem{Establish that the code you are demonstrating is the code
    you submitted to to \filesubmission.}
    \begin{itemize}
    \item If you are getting checked-off during lab time, show the TA that the
        file was submitted before it was due.
    \item Download the file into your number\_builder directory. If necessary,
        rename it to \textit{number\_builder.ino}.
    \end{itemize}
\checkoffitem{Show the TA your implementations of the Input/Output functions.}
\item [] (TA make note of which functions are implemented using memory-mapped I/O and which are not. Do not award credit for functions that do not use memory-mapped I/O. Pay attention to the debouncing code, making sure that it is not implemented with calls to \function{delay()}.)
\checkoffitem{Show that debouncing is correctly implemented. \\
    \textit{+1 The inputs are debounced in software without using blocking calls.}}
\item [] \textbf{Memory-Mapped Input/Output}
\checkoffitem{Ensure that the \function{loop()} function calls \function{test_io()} and not \function{build_number()}. Upload \textit{number\_builder.ino} to your \nano.}
\checkoffitem{Show that the display module is displaying the output. \\
    \textit{+8 The \function{send_halfbyte()} function is correctly implemented.}}
\item [] (If the display module does not displaying the output, then the remainder of the memory-mapped I/O items can be checked on the serial monitor.)
\checkoffitem{Demonstrate that both pushbuttons' positions are correctly detected. \\
    \textit{+2 The \function{xx_button_is_pressed()} functions are correctly implemented.}}
\checkoffitem{Demonstrate that both pushbuttons' positions are correctly detected. \\
    \textit{+2 The \function{xx_switch_in_xx_position()} functions are correctly implemented.}}
\checkoffitem{Demonstrate that when and only when both pushbuttons are pressed, the left LED (the built-in LED) illuminates. Demonstrate that when and only when both switches are in the right position, the right LED (the external LED) illuminates. \\
    \textit{+2 The \function{set_xx_led()} functions are correctly implemented.}}
\checkoffitem{Demonstrate that each of the keys on the keypad is correctly detected and that the absence of a keypress is also reported correctly. \\
    \textit{+8 The \function{get_keypress()} function is correctly implemented.}}
\item [] \textbf{Number Builder}
\precheckoffitem{If the display module does not displaying the output, then comment-out the line in \function{initalize_io()} that registers \function{send_halfbyte()} with the CowPi library.}
\precheckoffitem{Replace any other non-functioning I/O code with a call to the corresponding function from the CowPi library (see the starter code). \textit{Do NOT remove the debouncing code.}}
\checkoffitem{Ensure that the \function{loop()} function calls \function{build_number()} and not \function{test_io()}. Upload \textit{number\_builder.ino} to your \nano.}
\checkoffitem{Place both switches in the left position (left justified mode, decimal number base).}
\checkoffitem{Press 2, then 3. The right LED illuminates for \textonehalf\ second with each keypress. \\ Left-justified in the upper-left corner of the display module is shown: \\ \display{2} \\ and then: \\ \display{23} \\
    \textit{+1 Right LED illumination occurs as specified.} \\
    \textit{+1 Left justified mode is implemented correctly.} \\
    \textit{+1 The first digit is displayed in the correct position in this mode, making a blank display no longer blank.} \\
    \textit{+1 Subsequent digits update the number correctly in this mode.}}
\checkoffitem{Press B. The display is unchanged. \\
    \textit{+\textonehalf\ Decimal number base (positive values) is implemented correctly.}}
\checkoffitem{Press the right pushbutton. The left LED lluminates for \textonehalf\ second. \\ Left-justified in the lower-left corner of the display module is shown: \\ \display{23} \\ One second later, the display clears. \\
    \textit{+1 Left LED illumination occurs as specified.} \\
    \textit{+1 The right pushbutton causes a copy of the number to be displayed on the bottom row.} \\
    \textit{+1 The right pushbutton causes the display to clear after one second.}}
\checkoffitem{Place both switches in the right position (right justified mode, hexadecimal number base).}
\checkoffitem{Press 2, then 3. The right LED illuminates for \textonehalf\ second with each keypress. \\ Right-justified in the upper-right corner of the display module is shown: \\ \parbox{3cm}{\raggedleft\display{0x2} \\ and then: \\ \display{0x23}} \\
    \textit{+1 Right justified mode is implemented correctly.} \\
    \textit{+1 The first digit is displayed in the correct position in this mode, making a blank display no longer blank.} \\
    \textit{+1 Subsequent digits update the number correctly in this mode.}}
\checkoffitem{Press B. \\ \parbox{3cm}{\raggedleft\display{0x23B}} \\
    \textit{+\textonehalf\ Hexadecimal number base (positive values) is implemented correctly.}}
\checkoffitem{Press the left pushbutton. The left LED illuminates for  \textonehalf\ second. The display show, right-justified in the upper-right corner: \\
    \parbox{3cm}{\raggedleft\display{0xFFFFFDC5}} \\
    \textit{+\textonehalf\ The left pushbutton negates positive hexadecimal values.}}
\checkoffitem{Press A. \\ \parbox{3cm}{\raggedleft\display{0xFFFFDC5A}} \\
    \textit{+\textonehalf\ Hexadecimal number base (negative values) is implemented correctly.}}
\checkoffitem{Press the left pushbutton. \\
    \parbox{3cm}{\raggedleft\display{0x23A6}} \\
    \textit{+\textonehalf\ The left pushbutton negates negative hexadecimal values.}}
\checkoffitem{Press 7, 8, 9, C. \\
    \parbox{3cm}{\raggedleft\display{0x23A67}} \\
    \parbox{3cm}{\raggedleft\display{0x23A678}} \\
    \parbox{3cm}{\raggedleft\display{0x23A6789}} \\
    \parbox{3cm}{\raggedleft\display{0x23A6789C}}}
\checkoffitem{Press D. The system displays: \\ \display{too big} \\
    \textit{+\textonequarter\ Detects too-big positive hexadecimal numbers.} \\
    \textit{+\textonehalf\ Displays the correct ``too big'' error message.}}
\checkoffitem{Press the right pushbutton and wait for the display to clear.}
\checkoffitem{Enter 9, 8, 7, 6, 5, 4, 3, 2. \\
    \parbox{3cm}{\raggedleft\display{0x9}} \\
    \parbox{3cm}{\raggedleft\display{0x98}} \\
    \parbox{3cm}{\raggedleft\display{0x987}} \\
    \parbox{3cm}{\raggedleft\display{0x9876}} \\
    \parbox{3cm}{\raggedleft\display{0x9876}} \\
    \parbox{3cm}{\raggedleft\display{0x98765}} \\
    \parbox{3cm}{\raggedleft\display{0x987654}} \\
    \parbox{3cm}{\raggedleft\display{0x9876543}} \\
    \parbox{3cm}{\raggedleft\display{0x98765432}}}
\checkoffitem{Press 1. \\ \display{too big} \\
    \textit{+\textonequarter\ Detects too-big negative hexadecimal numbers.} \\
    \textit{+\textonequarter\ No false ``too big'' detection of hexadecimal numbers.}}
\checkoffitem{Press the right pushbutton and wait for the display to clear.}
\checkoffitem{Place the right swtich in the left position (decimal number base).}
\checkoffitem{Enter 1, 2, 3, 4, 5. \\
    \parbox{3cm}{\raggedleft\display{1}} \\
    \parbox{3cm}{\raggedleft\display{12}} \\
    \parbox{3cm}{\raggedleft\display{123}} \\
    \parbox{3cm}{\raggedleft\display{1234}} \\
    \parbox{3cm}{\raggedleft\display{12345}}}
\checkoffitem{Press the left pushbutton. \\
    \parbox{3cm}{\raggedleft\display{-12345}} \\
    \textit{+\textonehalf\ The left pushbutton negates positive decimal values.}}
\checkoffitem{Enter 6, 7, 8, 9, 0. \\
    \parbox{3cm}{\raggedleft\display{-123456}} \\
    \parbox{3cm}{\raggedleft\display{-1234567}} \\
    \parbox{3cm}{\raggedleft\display{-12345678}} \\
    \parbox{3cm}{\raggedleft\display{-123456789}} \\
    \parbox{3cm}{\raggedleft\display{-1234567890}} \\
    \textit{+\textonehalf\ Decimal number base (negative values) is implemented correctly.}}
\checkoffitem{Press the left pushbutton. \\
    \parbox{3cm}{\raggedleft\display{1234567890}} \\
    \textit{+\textonehalf\ The left pushbutton negates negative decimal values.}}
\checkoffitem{Press 1. \\ \display{too big} \\
    \textit{+\textonequarter\ Detects too-big positive decimal numbers.}}
\checkoffitem{Enter 1, 2, 3, 4, 5, 6, 7, 8, 9, 0. \\
    \parbox{3cm}{\raggedleft\display{1}} \\
    \parbox{3cm}{\raggedleft\display{12}} \\
    \parbox{3cm}{\raggedleft\display{123}} \\
    \parbox{3cm}{\raggedleft\display{1234}} \\
    \parbox{3cm}{\raggedleft\display{12345}} \\
    \parbox{3cm}{\raggedleft\display{123456}} \\
    \parbox{3cm}{\raggedleft\display{1234567}} \\
    \parbox{3cm}{\raggedleft\display{12345678}} \\
    \parbox{3cm}{\raggedleft\display{123456789}} \\
    \parbox{3cm}{\raggedleft\display{1234567890}}}
\checkoffitem{Press the left pushbutton. \\
    \parbox{3cm}{\raggedleft\display{-1234567890}}}
\checkoffitem{Press 0. \\ \display{too big} \\
    \textit{+\textonequarter\ Detects too-big negative decimal numbers.} \\
    \textit{+\textonequarter\ No false ``too big'' detection of decimal numbers.}}
\item [] \textbf{Overall} \\
    \textit{+\textonehalf\ Button presses lasting fewer than 500ms are treated as a single press.} \\
    \textit{+\textonehalf\ Key presses lasting fewer than 500ms are treated as a single press.}
\end{enumerate}

This concludes the demonstration of your system's functionality. The TAs will
later examine your code for violations of the assignment's constraints. If your
code looks like it is tailored for this checklist, the TAs may re-grade using a
different checklist\texttt{.}
\end{document}
