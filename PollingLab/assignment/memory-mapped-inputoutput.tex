In this section, you will use the data structures provided by the CowPi library to access the \developmentboard's memory-mapped I/O registers.
You will use the same test code from Section~\ref{sec:populateKeypad} to test your code.

If you have already implemented the system from Section~\ref{sec:SimpleSystem}, you may want to make a backup copy of your program now.

Make sure that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.

\subsection{Simple Inputs and Outputs}

You will use an array of \lstinline{cowpi_ioport_t} structures to access the memory-mapped I/O registers for the \developmentboard's external pins.

Read Section~4.1 of the Cow Pi datasheet.
After you have done so,
\begin{itemize}
    \item Uncomment the first line of the starter code's \function{initialize_io()} function, and
    \item Assign the appropriate address to the \lstinline{ioports} pointer on that line.
\end{itemize}

\begin{lstlisting}
void initialize_io(void) {
  // ioports = (cowpi_ioport_t *)(cowpi_io_base + 0);
  // i2c = (cowpi_i2c_t *)(cowpi_io_base + 0);
  // cowpi_lcd1602_set_send_halfbyte_function(send_halfbyte);
}
\end{lstlisting}

You can now use the \lstinline{ioports} pointer as an array of \lstinline{cowpi_ioport_t} structures, which you can index using the \lstinline{D0_D7}, \lstinline{D8_D13}, and \lstinline{D14_D19} named constants.

\subsubsection{Simple Inputs}

Locate the \function{left_button_is_pressed()}, \function{right_button_is_pressed()}, \\ \function{left_switch_in_left_position}, \function{left_switch_in_right_position()}, \\ \function{right_switch_in_left_position()}, and  \function{right_switch_in_right_position()} functions.
In the starter code, these functions are implemented by calling functions in the CowPi library, and they are not debounced.\footnote{
The test code has debouncing code, but a better design would have debouncing code in the functions that report the controls' positions.}

\begin{itemize}
    \item Modify these six functions to have debouncing code, and
    \item Replace the calls to CowPi library functions with code that uses the \lstinline{ioports} array to ascertain the controls' positions.
\end{itemize}

Make sure that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
The output will include the positions of the left and right buttons (``U'' for up and ``D'' for down) and of the left and right switches (``L'' for left position and ``R'' for right position).

\subsubsection{Simple Outputs}

Locate the \function{set_left_led()} and \function{set_right_led()} functions.
In the starter code, these functions are implemented by calling functions in the CowPi library.

\begin{itemize}
    \item Modify these two functions to replace the calls to CowPi library functions with code that uses the \lstinline{ioports} array to turn the LEDs on or off.
\end{itemize}

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
If both buttons are pressed then the left LED will illuminate, and if both switches are in the right position then the right LED will illuminate.

\subsection{Scanned Input}

Locate the \function{get_keypress()} function.
Not including the debouncing code, the implementation in the starter code calls the CowPi library's \function{cowpi_get_keypress()} function.
The \function{cowpi_get_keypress()} function returns a \lstinline{char} corresponding to the character on the pressed key,
but the \function{get_keypress()} function is supposed to return a \lstinline{uint8_t} that has the hexadecimal value of the pressed key (considering \# as 0xE and * as 0xF).
Because of this, the rest of the implementation is a \lstinline{swtich} statement to obtain the correct value from the \function{keys} nested array.

Read Section~1.2 of the Cow Pi datasheet.
After you have done so:

\begin{itemize}
    \item Preserve the debouncing code in \function{get_keypress()}, and
    \item Replace the starter code's call to \function{cowpi_get_keypress()} and \lstinline{switch} statement with code that scans the keyboard.
        \begin{itemize}
            \item Use the \lstinline{ioports} array to read from and write to the appropriate pins,
            \item Use \lstinline{delayMicroseconds(1)} for the delay shown on line 4 of the pseudocode in Section~1.2.2 of the datasheet, and
            \item Use the \lstinline{keys} nested array to obtain the correct integer value for the key at a given row and column.
        \end{itemize}
\end{itemize}

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
The output will include the key that was pressed (if any), a hyphen if no key is being pressed, or a question mark if \function{get_keypress()} returns an invalid value.


\subsection{Display Module}

You will use a pointer to a \lstinline{cowpi_i2c_t} structure to access the memory-mapped I/O registers for the \developmentboard's I$^2$C (aks ``TWI'') hardware,
and you will use those registers to send data to the display module.

Read Section~1.3 of the Cow Pi datasheet to familiarize yourself with the physical characteristics of the display module.
Read the datasheet's Section~4.2 to familiarize youself with the I$^2$C registers (Sections~4.2.1--4.2.2), with the I$^2$C handshake and transmission sequence (Section~4.2.3), and with the data format and the steps required by the display module itself (Section~4.2.4). After you have done so:

\begin{itemize}
    \item Uncomment the second line of the starter code's \function{initialize_io()} function, and
    \item Assign the appropriate address to the \lstinline{i2c} pointer on that line.
\end{itemize}

You can now use the \lstinline{i2c} pointer to operate the I$^2$C hardware.
Now locate the \function{send_halfbyte()} function.

\begin{itemize}
    \item Implement the pseudocode from the datasheet's Section~4.2.3, to
    \item Send the three bytes of data described in the datasheet's Section~4.2.4.
        \begin{itemize}
            % \item You may handle the error conditions show in the pseudocode in whatever manner you see fit; it would be best to do so in a manner that allows you to determine \textit{which} error is occurring.
            \item Use \lstinline{delayMicroseconds(1)} to implement the pulse described in Section~4.2.4 of the datasheet.
        \end{itemize}
\end{itemize}

After you are satisfied that you have implemented the \function{send_halfbyte()} function correctly:

\begin{itemize}
    \item Uncomment the third line of the starter code's \function{initialize_io()} function to register \function{send_halfbyte()} with the CowPi library's LCD1602 code.
\end{itemize}

All of the functions in the CowPi library that send characters or commands to the display module will now make use of your \function{send_halfbyte()} function.

Confirm that \textit{number\_builder.ino}'s \function{loop()} function calls \function{test_io()} and not \function{build_number()}.
Upload the program to your \developmentboard.
If the test code displays its outputs on the display module, then you implemented \function{send_halfbyte()} correctly. If the test code displays its outputs on the Serial Monitor but not the display module, or if the test code does not run at all, then there is an error in your code.