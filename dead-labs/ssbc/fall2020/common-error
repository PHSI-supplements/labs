The value being built is not initially 0, but instead is initially the previous operand.
The value being built is not initially 0; while the display initially shows 0, if operand has a non-zero value and I toggle the switch on & off, the operand retains its original value.
(3 pt per operand)

Operation clears the operands.
(2 pt per operation)

The "tens" and "hundreds" places are blank when they should be 0. For example, 999+1=1  0.
(2 pt per operation)

The "tens" and "hundreds" places are blank when they should be 0. For example, 999+1=1  0.
(2 pt per operation)

Rather than having the signal handler take the appropriate action based on the program's state, you have different a different signal handler registered for each program state.
(1 pt)

The flickering display, while distracting, is not addressed in the part 2 rubric.

There is no need to repeatedly re-register the signal handler.


12345 displays as .... (should be Err)
5000+5000 = 0000 (should be Err)
10-20 = 0 (should be -10)
1 - 2000 = .... (should be Err)

10-20 = Err (should be -10)
Too-great operand case does not preserve original operand: operand1=5; operand2=0; attempt to enter operand1=12345, properly displays Err; attempt to add operands displays .... but should display 5.



