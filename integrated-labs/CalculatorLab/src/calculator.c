/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file calculator.c
 *
 * @author Christopher A. Bohn
 *
 * @brief A four-function calculator that uses other, student-written code.
 *
 ******************************************************************************/

/*
 * CalculatorLab (c) 2020-25 Christopher A. Bohn
 *
 * Starter code licensed under the Apache License, Version 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <CowPi.h>
#include <stdlib.h>
#include <ctype.h>
#include "display.h"
#include "seven_segment_pla.h"
#include "number_builder.h"
#include "calculator.h"

enum operations {
    ADD = 0,
    SUBTRACT,
    MULTIPLY,
    DIVIDE,
    EQUALS,
    NONE
};

static char const operator_characters[] = {'A', 'B', 'C', 'D', '#'};
static char const ignore_character = '*';

static uint8_t const operator_display[] = {
        0b00000111, // ADD
        0b00000001, // SUBTRACT
        0b00110111, // MULTIPLY
        0b01001001, // DIVIDE
        0b00001001, // EQUALS
        0b00000000, // NONE
};

static uint8_t const error_display[] = {
        0b00000000,
        0b10100000, // !
        0b00000101, // r
        0b00011101, // o
        0b00000101, // r
        0b00000101, // r
        0b01001111, // E
        0b00000000
};

static int32_t const ERROR = (int32_t) 0xFFFFFFFF;

static char buffer[18] = {0};

static int32_t apply_operation(int16_t accumulator, int16_t operand, enum operations operation) {
    int32_t result = 0;
    switch (operation) {
        case NONE:
            result = (int32_t) accumulator;
            break;
        case EQUALS:
            result = (int32_t) operand;
            break;
        case ADD:
            result = (int32_t) accumulator + (int32_t) operand;
            if (accumulator > 0 && operand > 0 && (result & 0xFFFF8000) != 0) {
                result = ERROR;
            }
            if (accumulator < 0 && operand < 0 && (result & 0xFFFF8000) != 0xFFFF8000) {
                result = ERROR;
            }
            break;
        case SUBTRACT:
            result = (int32_t) accumulator - (int32_t) operand;
            if (accumulator > 0 && operand < 0 && (result & 0xFFFF8000) != 0) {
                result = ERROR;
            }
            if (accumulator < 0 && operand > 0 && (result & 0xFFFF8000) != 0xFFFF8000) {
                result = ERROR;
            }
            break;
        case MULTIPLY:
            ;   // separate the label from the declaration
            bool result_should_be_negative = (accumulator & 0x8000) ^ (operand & 0x8000);
            if (!result_should_be_negative
                && (((uint32_t) accumulator * (uint32_t) operand) & 0xFFFF8000)) {
                result = ERROR;
            } else if (result_should_be_negative
                       &&  (((uint32_t) accumulator * (uint32_t) operand) & 0xFFFF0000)
                       && !(((uint32_t) accumulator * (uint32_t) operand) & 0x00008000)) {
                result = ERROR;
            } else {
                result = (int32_t) accumulator * (int32_t) operand;
            }
            break;
        case DIVIDE:
            if (operand == 0) {
                result = ERROR;
            } else {
                result = (int32_t) accumulator / (int32_t) operand;
            }
            break;
        default:
            sprintf(buffer, "ERROR line %d\n", __LINE__);
            display_string(7, buffer);
    }
    return result;
}

static void output(int16_t number, enum operations operation, bool error) {
    uint8_t digits[8] = {0};
    uint8_t const *display = error ? error_display : digits;
    if (!error) {
        bool is_negative = false;
        if (number < 0) {
            is_negative = true;
            number = -number;
        }
        int i = 0;
        do {
            div_t division_result = div(number, 10);
            number = (int16_t) division_result.quot;
            digits[i++] = bcd_to_7segment_pla(division_result.rem);
        } while (number && i < 7);
        if (is_negative) {
            digits[i] = 0b00000001;
        }
    }
    for (int i = 0; i < 7; i++) {
        digitalWrite(17, 0);
        cowpi_spi_transmit(i + 1);
        cowpi_spi_transmit(display[i]);
        digitalWrite(17, 1);
        uint32_t start = get_microseconds();
        while (get_microseconds() - start < 1000) {}
    }
    digitalWrite(17, 0);
    cowpi_spi_transmit(8);
    cowpi_spi_transmit(operator_display[operation]);
    digitalWrite(17, 1);
    uint32_t start = get_microseconds();
    while (get_microseconds() - start < 1000) {}
}

void calculate(void) {
    static enum {
        ENTERING_ONLY_OPERAND1_DEFINED,
        ONLY_OPERAND1_DEFINED,
        ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION,
        BUILDING_OPERAND2_WITHOUT_OPERATION,
        ENTERING_OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED,
        OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED,
        ENTERING_BUILDING_OPERAND2_WITH_OPERATION,
        BUILDING_OPERAND2_WITH_OPERATION,
        ACCUMULATOR_ERROR
    } state = ENTERING_ONLY_OPERAND1_DEFINED;
    static int16_t accumulator = 0;
    static int16_t operand = 0;
    static bool error_condition = false;
    static enum operations operation = NONE;
    static char last_key = '\0';
    build_number();
    int16_t number = get_number();
    error_condition |= number_overflowed();
    char key = cowpi_debounce_byte(cowpi_get_keypress(), KEYPAD);
    switch (state) {
        case ENTERING_ONLY_OPERAND1_DEFINED:
            output(accumulator, operation, error_condition);
            state = ONLY_OPERAND1_DEFINED;
            break;
        case ONLY_OPERAND1_DEFINED:
            if (cowpi_debounce_byte(cowpi_right_button_is_pressed(), RIGHT_BUTTON_DOWN) && accumulator != 0) {
                accumulator = 0;
                operand = 0;
                error_condition = false;
                operation = NONE;
                state = ENTERING_ONLY_OPERAND1_DEFINED;
            } else if (number != operand) {
                last_key = key;
                operand = number;
                operation = NONE;
                state = ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION;
            } else if (key != last_key) {
                last_key = key;
                if (key == '0'){
                    // explicitly introducing 0 as operand2
                    // no change to operand2 (still 0)
                    operation = NONE;
                    state = ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION;
                } else {
                    for (enum operations op = ADD; op <= DIVIDE; op++) {
                        if (key == operator_characters[op]) {
                            operation = op;
                            state = ENTERING_OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED;
                        }
                    }
                }
            } else {}
            break;
        case ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION:
            output(operand, operation, error_condition);
            state = BUILDING_OPERAND2_WITHOUT_OPERATION;
            break;
        case BUILDING_OPERAND2_WITHOUT_OPERATION:
            if (number != operand) {
                last_key = key;
                operand = number;
                if (number != 0) {
                    state = ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION;
                } else {
                    error_condition = false;
                    state = ENTERING_ONLY_OPERAND1_DEFINED;
                }
            } else if (key != last_key && !isdigit(key)) {
                last_key = key;
                if (key != '\0' && key != ignore_character) {
                    accumulator = number;
                    reset_number();
                    operand = 0;
                    state = ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION;
                }
                if (key == operator_characters[EQUALS]) {
                    operation = EQUALS;
                    state = ENTERING_ONLY_OPERAND1_DEFINED;
                } else {
                    for (enum operations op = ADD; op <= DIVIDE; op++) {
                        if (key == operator_characters[op]) {
                            operation = op;
                            state = ENTERING_OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED;
                        }
                    }
                }
                if (key != '\0' && state == BUILDING_OPERAND2_WITHOUT_OPERATION) {
                    sprintf(buffer, "ERROR line %d\n", __LINE__);
                    display_string(7, buffer);
                }
            } else if (key != last_key && error_condition) {
                state = ENTERING_BUILDING_OPERAND2_WITHOUT_OPERATION;
            } else {}
            break;
        case ENTERING_OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED:
            output(accumulator, NONE, error_condition);     // don't show operator yet
            state = OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED;
            break;
        case OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED:
            cowpi_illuminate_right_led();                   // show that there's an operation specified
            cowpi_illuminate_left_led();
            if (cowpi_debounce_byte(cowpi_right_button_is_pressed(), RIGHT_BUTTON_DOWN)) {
                cowpi_deluminate_right_led();
                cowpi_deluminate_left_led();
                operand = 0;
                operation = NONE;
                error_condition = false;
                state = ENTERING_ONLY_OPERAND1_DEFINED;
            } else if (number != operand || (key != last_key && key == '0')) {
                last_key = key;
                operand = number;
                state = ENTERING_BUILDING_OPERAND2_WITH_OPERATION;
            } else {}
            break;
        case ENTERING_BUILDING_OPERAND2_WITH_OPERATION:
            output(operand, operation, error_condition);
            state = BUILDING_OPERAND2_WITH_OPERATION;
            break;
        case BUILDING_OPERAND2_WITH_OPERATION:
            if (number != operand) {
                last_key = key;
                operand = number;
                if (number == 0) {
                    error_condition = false;
                }
                state = ENTERING_BUILDING_OPERAND2_WITH_OPERATION;
            } else if (key != last_key && !isdigit(key)) {
                last_key = key;
                if (key != '\0' && key != ignore_character) {
                    int32_t result = apply_operation(accumulator, operand, operation);
                    if (result == ERROR) {
                        operation = NONE;
                        error_condition = true;
                        state = ACCUMULATOR_ERROR;
                        break;  // I'm not thrilled about breaking here, but I'll pinch my nose and do it anyway
                    }
                    accumulator = (int16_t) result;
                    reset_number();
                    operand = 0;
                }
                if (key == operator_characters[EQUALS]) {
                    operation = EQUALS;
                    state = ENTERING_ONLY_OPERAND1_DEFINED;
                } else {
                    for (enum operations op = ADD; op <= DIVIDE; op++) {
                        if (key == operator_characters[op]) {
                            operation = op;
                            state = ENTERING_OPERATION_SPECIFIED_BUT_OPERAND2_UNDEFINED;
                        }
                    }
                }
                if (key != '\0' && state == BUILDING_OPERAND2_WITH_OPERATION) {
                    sprintf(buffer, "ERROR line %d\n", __LINE__);
                    display_string(7, buffer);
                }
            } else if (key != last_key && error_condition) {
                state = ENTERING_BUILDING_OPERAND2_WITH_OPERATION;
            } else {}
            break;
        case ACCUMULATOR_ERROR:
            output(number, operation, error_condition);
            cowpi_deluminate_left_led();
            cowpi_deluminate_right_led();
            while (!cowpi_debounce_byte(cowpi_right_button_is_pressed(), RIGHT_BUTTON_DOWN)) {}
            reset_number();
            accumulator = 0;
            error_condition = false;
            operation = NONE;
            state = ENTERING_ONLY_OPERAND1_DEFINED;
            break;
        default:
            sprintf(buffer, "ERROR line %d\n", __LINE__);
            display_string(7, buffer);
    }
}
