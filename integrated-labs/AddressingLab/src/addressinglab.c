/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file addressinglab.c
 *
 * @author Christopher A. Bohn
 *
 * @brief Driver code for AddressingLab.
 *
 ******************************************************************************/

/*
 * AddressingLab (c) 2021-25 Christopher A. Bohn
 *
 * Starter code licensed under the Apache License, Version 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "caesarcipher.h"

char *get_string_input(char *restrict destination, char const *restrict prompt) {
    if (!destination) {
        fprintf(stderr, "`get_string_input` called with nullptr destination!\n");
        return nullptr;
    }
    printf("%s: ", prompt);
    fgets(destination, MAXIMUM_INPUT_LENGTH, stdin);
    destination[strlen(destination) - 1] = '\0';        // eliminates the undesired newline character
    return destination;
}

int get_numeric_input(char const *prompt) {
    char buffer[MAXIMUM_INPUT_LENGTH];
    get_string_input(buffer, prompt);
    return (int) strtol(buffer, nullptr, 10);
}

enum {
    CIPHER_ONLY = 1,
    CAPITALIZE_AND_CIPHER,
    VALIDATE_CIPHER
};

int main() {
    int option = get_numeric_input(
            "Options:\n"
            "1) caesar_cipher\n"
            "2) sentence_to_uppercase + caesar_cipher\n"
            "3) sentence_to_uppercase + caesar_cipher + validate_cipher\n"
            "Select the code you wish to check"
    );
    if (option < 1 || option > 3) {
        printf("Invalid choice %d. Please select a choice between 1 and 3.\n", option);
        exit(1);
    }
    char *plaintext = get_string_input(malloc(MAXIMUM_INPUT_LENGTH), "Enter the plaintext");
    int key = get_numeric_input("Enter the key, a number between 1 and 25");
    if (key < 1 || key > 25) {
        printf("Invalid key %d. Please select a key between 1 and 25.\n", key);
        exit(1);
    }
    char *capitalized_plaintext;
    if (option == CIPHER_ONLY) {
        capitalized_plaintext = plaintext;
    } else {
        capitalized_plaintext = sentence_to_uppercase(malloc(MAXIMUM_INPUT_LENGTH), plaintext);
    }
    char *ciphertext = caesar_cipher(malloc(MAXIMUM_INPUT_LENGTH), capitalized_plaintext, key);
    printf("Ciphertext: %s\n", ciphertext);
    if (option == VALIDATE_CIPHER) {
        struct cipher_package package = {
                .plaintext = capitalized_plaintext,
                .ciphertext = ciphertext,
                .key = key,
                .sentence_length = (int) strlen(plaintext)
        };
        printf("Plaintext: %s\n", plaintext);
        printf("Key: %d\n", key);
        printf("Length: %d\n", package.sentence_length);
        bool is_valid = validate_cipher(&package);
        printf("Cipher package %s valid.\n", is_valid ? "is" : "is not");
    }
    capitalized_plaintext = caesar_cipher(capitalized_plaintext, ciphertext, -key);
    printf("Deciphered plaintext: %s\n", capitalized_plaintext);
    free(plaintext);
    free(ciphertext);
    if (option > CIPHER_ONLY) {
        free(capitalized_plaintext);
    }
    return 0;
}
