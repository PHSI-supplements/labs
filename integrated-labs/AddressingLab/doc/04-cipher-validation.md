## Cipher Validation Function

The third function validates that the plaintext and ciphertext are a valid pair by confirming that 
they are both the length specified by the package's `sentence_length` field and that 
the inverse of the package's `key` field will decipher the ciphertext back to the plaintext. 
(See *caesarcipher.h* for the field details of the `cipher_package` structure.) 
Here is the equivalent C code:

```c
47. bool validate_cipher(struct cipher_package *package) {
48.     bool is_valid = (strlen(package->plaintext) == (size_t) package->sentence_length);
49.     is_valid = is_valid && (strlen(package->ciphertext) == (size_t) package->sentence_length);
50.     char deciphered_text[MAXIMUM_INPUT_LENGTH];
51.     caesar_cipher(deciphered_text, package->ciphertext, -(package->key));
52.     is_valid = is_valid && !strncmp(package->plaintext, deciphered_text, package->sentence_length);
53.     return is_valid;
54. }
```


### Access Fields in a Struct

[//]: # (Task 7)

Your final task is to position arguments into the correct registers for the call to `caesar_cipher` in line&nbsp;51.
The `deciphered_text` pointer has already been placed in the correct register; 
you do not need to take care of that. 
Each of the other two arguments is a field in the `cipher_package` structure. 
The base address for `package` is in `%rbx`.

- [ ] Find the line in *caesarcipher.s* that says
  ```asm
  ##### PLACE INSTRUCTIONS FOR TASK 7 ON NEXT TWO LINES #####
  ```
- [ ] On the next line, use a `movq` instruction to copy `package->ciphertext` into `%rsi`. 
  Use the displacement addressing mode in the source operand. 
  The base address is `%rbx`, and the `ciphertext` field is positioned 8 bytes after the base address.

On the next line after that, you need to place `-(package->key)` into `%edx`. 
Register `%edx` contains the value `0`, so we can generate `-(package->key)` by subtracting `package->key` from the content of `%edx` and placing the result in `%edx`.
- [ ] Insert a `subl` instruction to accomplish this. 
  Use displacement mode addressing to access `package->key`, which is $20_{10}$ bytes after the base address that is in `%rbx`.

Do not delete the `##### PLACE INSTRUCTIONS...` comment,
and do not delete or modify any other instructions.


### Check Your Work

- [ ] Compile and run *addressinglab*.
- [ ] Select option 3, "sentence_to_uppercase + caesar_cipher + validate_cipher".
- [ ] Test your code with several plaintext strings and keys.

All cipher packages generated by the `main` function are valid, and so any input you use should produce the report "Cipher package is valid."
If `validate_cipher` does not perform correctly go back and double-check each of the two instructions you placed in it.


---

|               [⬅️](03-capitalization.md)               |      [⬆️](../README.md)      |         [➡️](05-grading.md)          |
|:------------------------------------------------------:|:----------------------------:|:------------------------------------:|
| [Sentence to Uppercase Function](03-capitalization.md) | [Front Matter](../README.md) | [Turn-In and Grading](05-grading.md) |
