/*                       *
 * DO NOT EDIT THIS FILE *
 *                       */

/**************************************************************************//**
 *
 * @file caesarcipher.h
 *
 * @author Christopher A. Bohn
 *
 * @brief Nominal C code for the Caesar Cipher in AddressingLab.
 *
 * This code exists to generate the assembly code that students will edit.
 *
 ******************************************************************************/

#include <ctype.h>
#include <string.h>
#include "../src/caesarcipher.h"

char *caesar_cipher(char *restrict destination, char const *restrict text, int key) {
    char *target = destination;
    int reduced_character;
    while (*text) {
        if ('A' <= *text && *text <= 'Z') {
            reduced_character = *text - 'A';
            reduced_character = (reduced_character + key + 26) % 26;
            *target = (char) (reduced_character + 'A');
        } else {
            *target = *text;
        }
        target++;
        text++;
    }
    *target = '\0';
    return destination;
}

char *sentence_to_uppercase(char *restrict destination, char const *restrict sentence) {
    size_t length = strlen(sentence);
    for (size_t i = 0; i < length; i++) {
        destination[i] = (char) toupper(sentence[i]);
    }
    return destination;
}

bool validate_cipher(struct cipher_package *package) {
    bool is_valid = (strlen(package->plaintext) == (size_t) package->sentence_length);
    is_valid = is_valid && (strlen(package->ciphertext) == (size_t) package->sentence_length);
    char deciphered_text[MAXIMUM_INPUT_LENGTH];
    caesar_cipher(deciphered_text, package->ciphertext, -(package->key));
    is_valid = is_valid && !strncmp(package->plaintext, deciphered_text, package->sentence_length);
    return is_valid;
}